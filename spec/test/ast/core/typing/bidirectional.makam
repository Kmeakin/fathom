%extend bidirectional.

    % Tests

    tests : testsuite.
    %testsuite tests.


% FIXME: there seems to be a bug with indenting tests here - see https://github.com/astampoulis/makam/issues/94

    % Variables

>> synth_type (context [(semantics.format_intro_u8, semantics.format_type)]) (local 0) Type ?
>> Yes:
>> Type := semantics.format_type.


    % Annotated terms

>> synth_type (ann format_intro_u8 format_type) Type ?
>> Yes:
>> Type := semantics.format_type.

>> check_type (ann format_intro_u8 format_type) semantics.universe ?
>> Impossible.


>> synth_type (ann int_type universe) Type ?
>> Yes:
>> Type := semantics.universe.

>> check_type (ann int_type universe) semantics.format_type ?
>> Impossible.


    % Universes

>> synth_type universe Type ?
>> Impossible.


    % Functions

>> synth_type (function_type universe (function_type (local 0) (local 1))) Type ?
>> Yes:
>> Type := semantics.universe.

>> check_type (function_intro (function_intro (local 0))) (semantics.function_type semantics.universe (semantics.closure [] (function_type (local 0) (local 1)))) ?
>> Yes.

>> synth_type (function_type universe (function_type (local 0) (local 1))) Type ?
>> Yes:
>> Type := semantics.universe.

>> synth_type (function_elim (ann (function_intro (function_intro (local 0))) (function_type universe (function_type (local 0) (local 1)))) int_type) Type ?
>> Yes:
>> Type := semantics.function_type semantics.int_type (semantics.closure [semantics.int_type] (local 1)).


    % Pairs

>> check_type (pair_intro (int_intro 1) (array_intro [int_intro 42])) (semantics.pair_type semantics.int_type (semantics.closure [] (array_type int_type (local 0)))) ?
>> Yes.

>> synth_type (pair_elim_first (ann (pair_intro (int_intro 0) (array_intro [])) (pair_type int_type (array_type int_type (local 0))))) Type ?
>> Yes:
>> Type := semantics.int_type.

>> synth_type (pair_elim_second (ann (pair_intro (int_intro 0) (array_intro [])) (pair_type int_type (array_type int_type (local 0))))) Type ?
>> Yes:
>> Type := semantics.array_type semantics.int_type (semantics.int_intro 0).


    % Enumerations

>> synth_type (enum_type []) Type ?
>> Yes:
>> Type := semantics.universe.

>> synth_type (enum_type ["unit"]) Type ?
>> Yes:
>> Type := semantics.universe.

>> synth_type (enum_type ["true", "false"]) Type ?
>> Yes:
>> Type := semantics.universe.

>> check_type (enum_intro "unit") (semantics.enum_type ["unit"]) ?
>> Yes.

>> check_type (enum_intro "true") (semantics.enum_type ["true", "false"]) ?
>> Yes.

>> check_type (enum_intro "false") (semantics.enum_type ["true", "false"]) ?
>> Yes.

>> check_type (enum_intro "unit") (semantics.enum_type []) ?
>> Impossible.

>> check_type (enum_intro "unit") (semantics.enum_type ["true", "false"]) ?
>> Impossible.

>> check_type (enum_elim []) (semantics.function_type (semantics.enum_type []) (semantics.closure [] int_type)) ?
>> Yes.

>> check_type (enum_elim [("unit", int_intro 0)]) (semantics.function_type (semantics.enum_type ["unit"]) (semantics.closure [] int_type)) ?
>> Yes.

>> check_type (enum_elim [("true", int_intro 0), ("false", int_intro 1)]) (semantics.function_type (semantics.enum_type ["true", "false"]) (semantics.closure [] int_type)) ?
>> Yes.

>> check_type (enum_elim [("true", int_intro 0), ("false", int_intro 1)]) (semantics.function_type (semantics.enum_type ["false", "true"]) (semantics.closure [] int_type)) ?
>> Yes.

>> check_type (enum_elim [("true", enum_intro "unit"), ("false", int_intro 1)]) (semantics.function_type (semantics.enum_type ["true", "false"]) (semantics.closure [] (function_elim (enum_elim [("true", enum_type ["unit"]), ("false", int_type)]) (local 0)))) ?
>> Yes.

>> check_type (enum_elim [("true", int_intro 0), ("false", int_intro 1)]) (semantics.function_type (semantics.enum_type []) (semantics.closure [] int_type)) ?
>> Impossible.

>> check_type (enum_elim [("true", int_intro 0)]) (semantics.function_type (semantics.enum_type ["true", "false"]) (semantics.closure [] int_type)) ?
>> Impossible.


    % Arrays

>> check_type (array_intro []) (semantics.array_type semantics.int_type (semantics.int_intro 0)) ?
>> Yes.

>> check_type (array_intro [int_intro 1, int_intro 2, int_intro 3]) (semantics.array_type semantics.int_type (semantics.int_intro 3)) ?
>> Yes.


>> check_type (format_intro_pair format_intro_u16be (format_intro_array format_intro_u8 (local 0))) semantics.format_type ?
>> Yes.

    % Binary format descriptions

>> synth_type format_type Type ?
>> Impossible.

>> synth_type (format_intro_array format_intro_u8 (int_intro 3)) Type ?
>> Yes:
>> Type := semantics.format_type.

>> synth_type (format_elim (format_intro_array format_intro_u8 (int_intro 3))) Type ?
>> Yes:
>> Type := semantics.universe.

%end.
