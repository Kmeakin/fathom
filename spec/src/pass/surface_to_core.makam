% Bidirectional elaboration of the surface syntax into core terms
%
% Here we describe how we elaborate the surface language into the core
% language. This involves doing a number of things, including:
%
% - desugaring
% - unification
% - pattern compilation
% - etc.

%extend surface_to_core.

    %open fathom.ast.
    %open fathom.ast.core.semantics.


    context : type.

    context : list (string * int * value * value) -> context.

    %extend context.

        values : context -> list value -> prop.
        values (context Entries) Values :-
            map (pfun ( _, _, Elem, _ ) Elem => success) Entries Values.


        lookup_type : context -> string -> int -> value -> prop.
        lookup_type (context Entries) Name Level Type :-
            contains ( Name, Level, _, Type ) Entries.


        next_local : context -> value -> prop.
        next_local (context Entries) (neutral (local Level)) :-
            length Entries Level.


        add_local : context -> string -> value -> value -> context -> prop.
        add_local (context Entries) Name Elem Type
            (context (( Name, Level, Elem, Type ) :: Entries))
        :-
            length Entries Level.


        add_param : context -> string -> value -> context -> prop.
        add_param Context Name Type Context' :-
            next_local Context Elem,
            add_local Context Name Elem Type Context'.


        eval : context -> core.term -> value -> prop.
        eval Context Elem Elem' :-
            values Context Values,
            eval Values Elem Elem'.


        is_equal : context -> value -> value -> prop.
        is_equal (context Entries) Elem1 Elem2 :-
            length Entries Length,
            is_equal Length Elem1 Elem2.

    %end.


    % Elaboration rules

    % Check that a term is a type and elaborate it to a core term.
    is_type : context -> surface.term -> core.term -> prop.
    % Check that a term is an element of the given type and elaborate it to a core term.
    check_type : context -> surface.term -> value -> core.term -> prop.
    % Synthesize the type of a given term and elaborate it to a core term.
    synth_type : context -> surface.term -> value -> core.term -> prop.

    % A note on modes
    %
    % Makam does not support mode declarations (like in Mercury), but if it did
    % we'd assign the following mode declarations to the above predicates:
    %
    % ```
    % is_type : in -> in -> out -> semidet.
    % check_type : in -> in -> in -> out -> semidet.
    % synth_type : in -> in -> out -> out -> semidet.
    % ```

    % Conversion
    is_type Context SourceElem Elem:-
        synth_type Context SourceElem type_type Elem.
    is_type Context SourceElem Elem :-
        synth_type Context SourceElem format_type Elem.
    check_type Context SourceElem Type Elem :-
        synth_type Context SourceElem Type' Elem,
        context.is_equal Context Type Type'.

    % Variables
    synth_type Context (surface.name "Type") Type core.type_type.
    synth_type Context (surface.name "Format") Type core.format_type.
    synth_type Context (surface.name Name) Type (core.local Level) :-
        context.lookup_type Context Name Level Type.

    % Annotated terms
    synth_type Context (surface.ann SourceElem SourceType) Type' (core.ann Elem Type) :-
        is_type Context SourceType Type,
        context.eval Context Type Type',
        check_type Context SourceElem Type' Elem.

    % Universes
    % Functions
    % Pairs
    % Records
    % Enumerations
    % Integers
    % Arrays
    % Binary format descriptions

%end.
