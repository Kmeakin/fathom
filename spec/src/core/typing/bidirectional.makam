% Bidirectional Typing
%
% This section provides an operational semantics for the declarative
% typing rules in `core.typing.declarative`, and thus is intended to be
% a refinement of these rules. This means that some terms that are
% well-formed with respect to the declarative typing rules may _not_ be
% well-formed in the bidirectional typing rules, requiring additional
% type annotations in order to be considered valid.

%extend bidirectional.

    % FIXME: somehow import `semantics.(value, neutral, closure)` in
    % order to make this module a bit less verbose. See this comment for
    % more information: https://github.com/astampoulis/makam/issues/88#issuecomment-620318340


    % Bidirectional typing context.
    %
    % This stores the values and types of the bindings we have currently
    % traversed over, allowing us to evaluate terms and synthesize the
    % types of variables when we encounter them, and evaluate term.
    context : type.

    context : list (semantics.value * semantics.value) -> context.

    %extend context.

        values : context -> list semantics.value -> prop.
        values (context Entries) Values :-
            map tuple.fst Entries Values.


        lookup_type : context -> int -> semantics.value -> prop.
        lookup_type (context Entries) Index Type :-
            list.nth Entries Index ( _, Type ).


        next_local : context -> semantics.value -> prop.
        next_local (context Entries) (semantics.neutral (semantics.local Level)) :-
            length Entries Level.


        add_local : context -> semantics.value -> semantics.value -> context -> prop.
        add_local (context Entries) Value Type (context (( Value, Type ) :: Entries)).


        add_param : context -> semantics.value -> context -> prop.
        add_param Context Type Context' :-
            next_local Context LocalTerm,
            add_local Context LocalTerm Type Context'.


        eval : context -> term -> semantics.value -> prop.
        eval Context Term Value :-
            values Context Values,
            semantics.eval Values Term Value.


        is_equal : context -> semantics.value -> semantics.value -> prop.
        is_equal (context Entries) Value1 Value2 :-
            length Entries Length,
            semantics.is_equal Length Value1 Value2.

    %end.


    % Typing rules

    % Check that a term is a type in the current context.
    is_type : context -> term -> prop.
    % Check that a term is an element of the given type in the current context.
    check_type : context -> term -> semantics.value -> prop.
    % Synthesize the type of a given term in the current context.
    synth_type : context -> term -> semantics.value -> prop.

    % A note on modes
    %
    % Makam does not support mode declarations (like in Mercury), but if it did
    % we'd assign the following mode declarations to the above predicates:
    %
    % ```
    % is_type : in -> in -> semidet.
    % check_type : in -> in -> int -> semidet.
    % synth_type : in -> in -> out -> semidet.
    % ```

    % Conversion
    check_type Context Term Type :-
        synth_type Context Term Type',
        context.is_equal Context Type Type'.

    % Variables
    synth_type Context (local Index) Type :-
        context.lookup_type Context Index Type.

    % Annotated terms
    % FIXME: is_type?
    synth_type Context (ann Term Type) Type' :-
        is_type Context Type,
        context.eval Context Type Type',
        check_type Context Term Type'.

    % Universes
    is_type Context universe.

    % Unit
    is_type Context unit_type.
    synth_type Context unit_type semantics.universe.
    synth_type Context unit_intro semantics.unit_type.

    % Functions
    is_type Context (function_type InputType OutputType) :-
        is_type Context InputType,
        context.eval Context InputType InputType',
        context.add_param Context InputType' Context',
        is_type Context' OutputType.
    synth_type Context (function_type InputType OutputType) semantics.universe :-
        is_type Context InputType,
        context.eval Context InputType InputType',
        context.add_param Context InputType' Context'.
        is_type Context' OutputType.
    check_type Context (function_intro OutputTerm) (semantics.function_type InputType Closure) :-
        context.next_local Context LocalTerm,
        semantics.apply Closure LocalTerm OutputType,
        context.add_param Context InputType Context',
        check_type Context' OutputTerm OutputType.
    synth_type Context (function_elim Term InputTerm) OutputType :-
        synth_type Context Term (semantics.function_type InputType Closure),
        check_type Context InputTerm InputType,
        context.eval Context InputTerm InputValue,
        semantics.apply Closure InputValue OutputType.

    % Pairs
    is_type Context (pair_type FirstType SecondType) :-
        check_type Context FirstType semantics.universe,
        context.eval Context FirstType FirstType',
        context.add_param Context FirstType' Context',
        check_type Context' SecondType semantics.universe.
    synth_type Context (pair_type FirstType SecondType) semantics.universe :-
        check_type Context FirstType semantics.universe,
        context.eval Context FirstType FirstType',
        context.add_param Context FirstType' Context',
        check_type Context' SecondType semantics.universe.
    check_type Context (pair_intro FirstTerm SecondTerm) (semantics.pair_type FirstType Closure) :-
        check_type Context FirstTerm FirstType,
        context.eval Context FirstTerm FirstValue,
        context.add_local Context FirstValue FirstType Context',
        semantics.apply Closure FirstValue SecondType,
        check_type Context' SecondTerm SecondType.
    synth_type Context (pair_elim_first PairTerm) FirstType :-
        synth_type Context PairTerm (semantics.pair_type FirstType _).
    synth_type Context (pair_elim_second PairTerm) SecondType :-
        synth_type Context PairTerm (semantics.pair_type _ Closure),
        context.eval Context (pair_elim_first PairTerm) FirstValue,
        semantics.apply Closure FirstValue SecondType.

    % Booleans
    is_type Context bool_type.
    synth_type Context bool_type semantics.universe.
    synth_type Context (bool_intro _) semantics.bool_type.
    check_type Context (bool_elim BoolTerm TrueTerm FalseTerm) Type :-
        check_type Context BoolTerm semantics.bool_type,
        check_type Context TrueTerm Type,
        check_type Context FalseTerm Type.

    % Integers
    is_type Context int_type.
    synth_type Context int_type semantics.universe.
    synth_type Context (int_intro _) semantics.int_type.

    % Arrays
    is_type Context (array_type ElemType LenTerm) :-
        check_type Context ElemType semantics.universe,
        check_type Context LenTerm semantics.int_type.
    synth_type Context (array_type ElemType LenTerm) semantics.universe :-
        check_type Context ElemType semantics.universe,
        check_type Context LenTerm semantics.int_type.
    check_type Context (array_intro ElemTerms) (semantics.array_type ElemType (semantics.int_intro Len)) :-
        length ElemTerms Len,
        map (fun elem_term => check_type Context elem_term ElemType) ElemTerms.
    synth_type Context (array_elim ArrayTerm IndexTerm) ElemType :-
        % FIXME: ensure `IndexTerm` is in array bounds, possibly with refinement types?
        synth_type Context ArrayTerm (semantics.array_type ElemType _),
        check_type Context IndexTerm semantics.int_type.

    % Binary format descriptions
    is_type Context format_type.
    synth_type Context format_intro_unit semantics.format_type.
    synth_type Context format_intro_u8 semantics.format_type.
    synth_type Context format_intro_u16le semantics.format_type.
    synth_type Context format_intro_u16be semantics.format_type.
    synth_type Context format_intro_u32le semantics.format_type.
    synth_type Context format_intro_u32be semantics.format_type.
    synth_type Context format_intro_u64le semantics.format_type.
    synth_type Context format_intro_u64be semantics.format_type.
    synth_type Context format_intro_s8 semantics.format_type.
    synth_type Context format_intro_s16le semantics.format_type.
    synth_type Context format_intro_s16be semantics.format_type.
    synth_type Context format_intro_s32le semantics.format_type.
    synth_type Context format_intro_s32be semantics.format_type.
    synth_type Context format_intro_s64le semantics.format_type.
    synth_type Context format_intro_s64be semantics.format_type.
    synth_type Context (format_intro_array ElemType LenTerm) semantics.format_type :-
        check_type Context ElemType semantics.format_type,
        check_type Context LenTerm semantics.int_type.
    synth_type Context (format_intro_pair FirstType SecondType) semantics.format_type :-
        check_type Context FirstType semantics.format_type,
        context.eval Context (format_elim FirstType) FirstType',
        context.add_param Context FirstType' Context',
        check_type Context' SecondType semantics.format_type.
    is_type Context (format_elim Type) :-
        check_type Context Type semantics.format_type.
    synth_type Context (format_elim Type) semantics.universe :-
        check_type Context Type semantics.format_type.


    % Convenience predicates

    is_type : term -> prop.
    is_type Term :-
        is_type (context []) Term.

    synth_type : term -> semantics.value -> prop.
    synth_type Term Type :-
        synth_type (context []) Term Type.

    check_type : term -> semantics.value -> prop.
    check_type Term Type :-
        check_type (context []) Term Type.

%end.
