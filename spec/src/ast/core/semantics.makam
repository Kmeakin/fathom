% Semantics
%
% This section defines an operational semantics for language, using
% normalization-by-evaluation for performance reasons.

%extend semantics.

    %use "stdlib/functional".

    % The result of evaluating a term.
    value : type.
    % Neutral values are computations that are currently 'stuck' on some
    % as-yet unknown computation. We build up a 'spine' of eliminations
    % that cannot yet reduce in preperation for if they become 'unstuck'.
    neutral : type.
    % Closures are terms from the core syntax that have yet to be evaluated.
    % They capture an environment of values to be used later, when they are
    % finally evaluated.
    closure : type.
    choice_closure : type.

    % Neutral values
    neutral : neutral -> value.

    % Universes
    type_type : value.

    % Functions
    function_type : value -> closure -> value.  % Also known as: Pi type, Dependent product type
    function_intro : closure -> value.          % Also known as: Lambda abstraction, anonymous function

    % Pairs
    pair_type : value -> closure -> value.      % Also known as: Sigma type, Dependent sum type
    pair_intro : value -> value -> value.       % Also known as: Pair constructor

    % Enumerations
    enum_type : set string -> value.
    enum_intro : string -> value.
    enum_elim : choice_closure -> value.

    % Refinements
    %  refine_type : value -> closure -> value.
    %  refine_intro : value -> (* some proof from a solver here? *) -> value.

    % Staging
    %  stage_type : value -> value.
    %  stage_intro : value -> value.

    % Integers
    int_type : value.
    int_intro : int -> value.

    % Arrays
    array_type : value -> value -> value.
    array_intro : list value -> value.

    % Binary format descriptions
    format_type : value.
    format_intro_void : value.
    format_intro_unit : value.
    format_intro_u8 : value.
    format_intro_u16le : value.
    format_intro_u16be : value.
    format_intro_u32le : value.
    format_intro_u32be : value.
    format_intro_u64le : value.
    format_intro_u64be : value.
    format_intro_s8 : value.
    format_intro_s16le : value.
    format_intro_s16be : value.
    format_intro_s32le : value.
    format_intro_s32be : value.
    format_intro_s64le : value.
    format_intro_s64be : value.
    format_intro_array : value -> value -> value.
    format_intro_pair : value -> closure -> value.

    % Variables
    local : int -> neutral. % Local variables (using De Bruijn levels)

    % Suspended eliminations
    function_elim : neutral -> value -> neutral.
    pair_elim_first : neutral -> neutral.
    pair_elim_second : neutral -> neutral.
    enum_elim : choice_closure -> neutral -> neutral.
    %  stage_elim : neutral -> neutral.
    %  array_elim : neutral -> value -> neutral.
    format_elim : neutral -> neutral.

    closure : list value -> term -> closure.
    choice_closure : list value -> map string term -> choice_closure.


    % Evaluation of terms into values

    eval : list value -> term -> value -> prop.

    apply : closure -> value -> value -> prop.

    function_elim : value -> value -> value -> prop.
    pair_elim_first : value -> value -> prop.
    pair_elim_second : value -> value -> prop.
    %  stage_elim : value -> value -> prop.
    format_elim : value -> value -> prop.

    eval Values (local Index) Value :-
        list.nth Values Index Value.
    eval Values (ann Elem _) Value :-
        eval Values Elem Value.
    eval Values type_type type_type.
    eval Values (function_type InputType OutputType) (function_type InputType' (closure Values OutputType)) :-
        eval Values InputType InputType'.
    eval Values (function_intro OutputElem) (function_intro (closure Values OutputElem)).
    eval Values (function_elim Elem InputElem) Value' :-
        eval Values Elem Value,
        eval Values InputElem InputValue,
        function_elim Value InputValue Value'.
    eval Values (pair_type FirstType SecondType) (pair_type FirstType' (closure Values SecondType)) :-
        eval Values FirstType FirstType'.
    eval Values (pair_intro FirstElem SecondElem) (pair_intro FirstValue SecondValue) :-
        eval Values FirstElem FirstValue,
        eval Values SecondElem SecondValue.
    eval Values (pair_elim_first PairElem) FirstValue :-
        eval Values PairElem PairValue,
        pair_elim_first PairValue FirstValue.
    eval Values (pair_elim_second PairElem) SecondValue :-
        eval Values PairElem PairValue,
        pair_elim_second PairValue SecondValue.
    eval Values (enum_type Labels) (enum_type Labels).
    eval Values (enum_intro Label) (enum_intro Label).
    eval Values (enum_elim Clauses) (enum_elim (choice_closure Values Clauses)).
    eval Values int_type int_type.
    eval Values (int_intro Int) (int_intro Int).
    eval Values (array_type ElemType LenElem) (array_type ElemType' LenValue) :-
        eval Values ElemType ElemType',
        eval Values LenElem LenValue.
    eval Values (array_intro Elems) (array_intro ElemValues) :-
        map (fun term value => eval Values term value) Elems ElemValues.
    % FIXME: This breaks for neutral terms! We should use `array_elim` here.
    eval Values (array_elim ArrayElem IndexElem) ElemValue :-
        eval Values ArrayElem (array_intro ElemValues),
        eval Values IndexElem (int_intro Index),
        list.nth ElemValues Index ElemValue.
    eval Values format_type format_type.
    eval Values format_intro_void format_intro_void.
    eval Values format_intro_unit format_intro_unit.
    eval Values format_intro_u8 format_intro_u8.
    eval Values format_intro_u16le format_intro_u16le.
    eval Values format_intro_u16be format_intro_u16be.
    eval Values format_intro_u32le format_intro_u32le.
    eval Values format_intro_u32be format_intro_u32be.
    eval Values format_intro_u64le format_intro_u64le.
    eval Values format_intro_u64be format_intro_u64be.
    eval Values format_intro_s8 format_intro_s8.
    eval Values format_intro_s16le format_intro_s16le.
    eval Values format_intro_s16be format_intro_s16be.
    eval Values format_intro_s32le format_intro_s32le.
    eval Values format_intro_s32be format_intro_s32be.
    eval Values format_intro_s64le format_intro_s64le.
    eval Values format_intro_s64be format_intro_s64be.
    eval Values (format_intro_array ElemType LenElem) (format_intro_array ElemType' LenValue) :-
        eval Values ElemType ElemType',
        eval Values LenElem LenValue.
    eval Values (format_intro_pair FirstType SecondType) (format_intro_pair FirstType' (closure Values SecondType)) :-
        eval Values FirstType FirstType'.
    eval Values (format_elim Elem) Value' :-
        eval Values Elem Value,
        format_elim Value Value'.

    % Closure operations

    apply (closure Values Elem) InputValue Value :-
        eval (InputValue :: Values) Elem Value.

    % Eliminations

    function_elim (neutral Neutral) InputValue (neutral (function_elim Neutral InputValue)).
    function_elim (function_intro Closure) InputValue OutputValue :-
        apply Closure InputValue OutputValue.
    function_elim (enum_elim (choice_closure Values Clauses)) (neutral Neutral) (neutral (enum_elim (choice_closure Values Clauses) Neutral)).
    function_elim (enum_elim (choice_closure Values Clauses)) (enum_intro Label) OutputValue :-
        map.find Clauses Label OutputElem,
        eval Values OutputElem OutputValue.

    pair_elim_first (neutral Neutral) (neutral (pair_elim_first Neutral)).
    pair_elim_first (pair_intro FirstValue _) FirstValue.

    pair_elim_second (neutral Neutral) (neutral (pair_elim_second Neutral)).
    pair_elim_second (pair_intro _ SecondValue) SecondValue.

    % TODO: stage_elim

    format_elim (neutral Neutral) (neutral (format_elim Neutral)).
    format_elim format_intro_void (enum_type []).
    format_elim format_intro_unit (enum_type ["unit"]).
    format_elim format_intro_u8 int_type.
    format_elim format_intro_u16le int_type.
    format_elim format_intro_u16be int_type.
    format_elim format_intro_u32le int_type.
    format_elim format_intro_u32be int_type.
    format_elim format_intro_u64le int_type.
    format_elim format_intro_u64be int_type.
    format_elim format_intro_s8 int_type.
    format_elim format_intro_s16le int_type.
    format_elim format_intro_s16be int_type.
    format_elim format_intro_s32le int_type.
    format_elim format_intro_s32be int_type.
    format_elim format_intro_s64le int_type.
    format_elim format_intro_s64be int_type.
    format_elim (format_intro_array Elem Len) (array_type Elem' Len) :-
        format_elim Elem Elem'.
    format_elim (format_intro_pair First (closure Values Elem)) (pair_type First' (closure Values (format_elim Elem))) :-
        format_elim First First'.


    % Readback of values into terms in normal form

    readback : int -> neutral -> term -> prop.
    readback : int -> value -> term -> prop.

    readback Length (local Level : neutral) (local Index) :-
        % Convert De Bruijn levels to De Bruijn indices
        functional.do !(minus Length !(plus Level 1)) Index.
    readback Length (function_elim Neutral InputValue : neutral) (function_elim Elem InputElem) :-
        readback Length Neutral Elem,
        readback Length InputValue InputElem.
    readback Length (pair_elim_first Neutral : neutral) (pair_elim_first Elem) :-
        readback Length Neutral Elem.
    readback Length (pair_elim_second Neutral : neutral) (pair_elim_second Elem) :-
        readback Length Neutral Elem.
    readback Length (enum_elim (choice_closure Values Clauses) Neutral : neutral) (function_elim (enum_elim Clauses') Elem) :-
        map.mapvalues (pfun Elem Elem' => [Value Length] (
            eval Values Elem Value,
            length Values Length,
            readback Length Value Elem'
        )) Clauses Clauses',
        readback Length Neutral Elem.
    readback Length (format_elim Neutral : neutral) (format_elim Elem) :-
        readback Length Neutral Elem.

    readback Length (neutral Neutral) Elem :-
        readback Length Neutral Elem.
    readback Length type_type type_type.
    readback Length (function_type InputType Closure) (function_type InputType' OutputType') :-
        readback Length InputType InputType',
        apply Closure (neutral (local Length)) OutputType,
        plus Length 1 Length1,
        readback Length1 OutputType OutputType'.
    readback Length (function_intro Closure) (function_intro OutputElem') :-
        apply Closure (neutral (local Length)) OutputElem,
        plus Length 1 Length1,
        readback Length1 OutputElem OutputElem'.
    readback Length (pair_type FirstType Closure) (pair_type FirstType' SecondType') :-
        readback Length FirstType FirstType',
        apply Closure (neutral (local Length)) SecondType,
        plus Length 1 Length1,
        readback Length1 SecondType SecondType'.
    readback Length (pair_intro FirstValue SecondValue) (pair_intro FirstElem SecondElem) :-
        readback Length FirstValue FirstType,
        readback Length SecondValue SecondType.
    readback Length (enum_type Labels) (enum_type Labels).
    readback Length (enum_intro Label) (enum_intro Label).
    readback Length (enum_elim (choice_closure Values Clauses)) (enum_elim Clauses') :-
        map.mapvalues (pfun Elem Elem' => [Value Length] (
            eval Values Elem Value,
            length Values Length,
            readback Length Value Elem'
        )) Clauses Clauses'.
    readback Length int_type int_type.
    readback Length (int_intro Int) (int_intro Int).
    readback Length (array_type ElemValue LenValue) (array_type ElemType LenElem) :-
        readback Length ElemValue ElemType,
        readback Length LenValue LenElem.
    readback Length (array_intro ElemValues) (array_intro Elems) :-
        map (fun value term => readback Length value term) ElemValues Elems.
    readback Length format_type format_type.
    readback Length format_intro_void format_intro_void.
    readback Length format_intro_unit format_intro_unit.
    readback Length format_intro_u8 format_intro_u8.
    readback Length format_intro_u16le format_intro_u16le.
    readback Length format_intro_u16be format_intro_u16be.
    readback Length format_intro_u32le format_intro_u32le.
    readback Length format_intro_u32be format_intro_u32be.
    readback Length format_intro_u64le format_intro_u64le.
    readback Length format_intro_u64be format_intro_u64be.
    readback Length format_intro_s8 format_intro_s8.
    readback Length format_intro_s16le format_intro_s16le.
    readback Length format_intro_s16be format_intro_s16be.
    readback Length format_intro_s32le format_intro_s32le.
    readback Length format_intro_s32be format_intro_s32be.
    readback Length format_intro_s64le format_intro_s64le.
    readback Length format_intro_s64be format_intro_s64be.
    readback Length (format_intro_array ElemValue LenValue) (format_intro_array ElemType LenElem) :-
        readback Length ElemValue ElemType,
        readback Length LenValue LenElem.
    readback Length (format_intro_pair FirstType Closure) (format_intro_pair FirstType' SecondType') :-
        readback Length FirstType FirstType',
        apply Closure (neutral (local Length)) SecondType,
        plus Length 1 Length1,
        readback Length1 SecondType SecondType'.


    % Normalization-by-evaluation

    normalize : list value -> term -> term -> prop.
    normalize Values Elem Elem' :-
        eval Values Elem Value,
        length Values Length,
        readback Length Value Elem'.

    normalize : term -> term -> prop.
    normalize Elem Elem' :-
        normalize [] Elem Elem'.


    % Equality of values

    is_equal : int -> neutral -> neutral -> prop.
    is_equal : int -> value -> value -> prop.

    is_equal Length (local Level : neutral) (local Level).
    is_equal Length (function_elim Neutral1 InputValue1 : neutral) (function_elim Neutral2 InputValue2) :-
        is_equal Length Neutral1 Neutral2,
        is_equal Length InputValue1 InputValue2.
    is_equal Length (pair_elim_first Neutral1 : neutral) (pair_elim_first Neutral2) :-
        is_equal Length Neutral1 Neutral2.
    is_equal Length (pair_elim_second Neutral1 : neutral) (pair_elim_second Neutral2) :-
        is_equal Length Neutral1 Neutral2.
    is_equal Length (enum_elim (choice_closure Values1 Clauses1) Neutral1 : neutral) (enum_elim (choice_closure Values2 Clauses2) Neutral2) :-
        map.keys Clauses1 Labels1,
        map.keys Clauses2 Labels2,
        eqv Labels1 Labels2,
        set.map (pfun Label => [Elem1 Elem2 Value1 Value2] (
            map.find Clauses1 Label Elem1,
            map.find Clauses2 Label Elem2,
            eval Values1 Elem1 Value1,
            eval Values2 Elem2 Value2,
            is_equal Length Value1 Value2
        )) Labels1,
        is_equal Length Neutral1 Neutral2.
    is_equal Length (format_elim Neutral1 : neutral) (format_elim Neutral2) :-
        is_equal Length Neutral1 Neutral2.

    is_equal Length (neutral Neutral1) (neutral Neutral2) :-
        is_equal Length Neutral1 Neutral2.
    is_equal Length type_type type_type.
    is_equal Length (function_type InputType1 Closure1) (function_type InputType2 Closure2) :-
        is_equal Length InputType1 InputType2,
        apply Closure1 (neutral (local Length)) OutputType1,
        apply Closure2 (neutral (local Length)) OutputType2,
        plus Length 1 Length1,
        is_equal Length1 OutputType1 OutputType2.
    is_equal Length (function_intro Closure1) (function_intro Closure2) :-
        apply Closure1 (neutral (local Length)) OutputValue1,
        apply Closure2 (neutral (local Length)) OutputValue2,
        plus Length 1 Length1,
        is_equal Length1 OutputValue1 OutputValue2.
    is_equal Length (pair_type FirstType1 Closure1) (pair_type FirstType2 Closure2) :-
        is_equal Length FirstType1 FirstType2,
        apply Closure1 (neutral (local Length)) SecondType1,
        apply Closure2 (neutral (local Length)) SecondType2,
        plus Length 1 Length1,
        is_equal Length1 SecondType1 SecondType2.
    is_equal Length (pair_intro FirstElem1 SecondElem1) (pair_intro FirstElem2 SecondElem2) :-
        is_equal Length FirstElem1 FirstElem2,
        is_equal Length SecondElem1 SecondElem2.
    is_equal Length (enum_type Labels1) (enum_type Labels2) :-
        eqv Labels1 Labels2.
    is_equal Length (enum_intro Label1) (enum_intro Label2) :-
        eqv Label1 Label2.
    is_equal Length (enum_elim (choice_closure Values1 Clauses1)) (enum_elim (choice_closure Values2 Clauses2)) :-
        map.keys Clauses1 Labels1,
        map.keys Clauses2 Labels2,
        eqv Labels1 Labels2,
        set.map (pfun Label => [Elem1 Elem2 Value1 Value2] (
            map.find Clauses1 Label Elem1,
            map.find Clauses2 Label Elem2,
            eval Values1 Elem1 Value1,
            eval Values2 Elem2 Value2,
            is_equal Length Value1 Value2
        )) Labels1.
    is_equal Length int_type int_type.
    is_equal Length (int_intro Int) (int_intro Int).
    is_equal Length (array_type ElemType1 LenElem1) (array_type ElemType2 LenElem2) :-
        is_equal Length ElemType1 ElemType2,
        is_equal Length LenElem1 LenElem2.
    is_equal Length (array_intro ElemValues1) (array_intro ElemValues2) :-
        map (fun value1 value2 => is_equal Length value1 value2) ElemValues1 ElemType2.
    is_equal Length format_type format_type.
    is_equal Length format_intro_void format_intro_void.
    is_equal Length format_intro_unit format_intro_unit.
    is_equal Length format_intro_u8 format_intro_u8.
    is_equal Length format_intro_u16le format_intro_u16le.
    is_equal Length format_intro_u16be format_intro_u16be.
    is_equal Length format_intro_u32le format_intro_u32le.
    is_equal Length format_intro_u32be format_intro_u32be.
    is_equal Length format_intro_u64le format_intro_u64le.
    is_equal Length format_intro_u64be format_intro_u64be.
    is_equal Length format_intro_s8 format_intro_s8.
    is_equal Length format_intro_s16le format_intro_s16le.
    is_equal Length format_intro_s16be format_intro_s16be.
    is_equal Length format_intro_s32le format_intro_s32le.
    is_equal Length format_intro_s32be format_intro_s32be.
    is_equal Length format_intro_s64le format_intro_s64le.
    is_equal Length format_intro_s64be format_intro_s64be.
    is_equal Length (format_intro_array ElemType1 LenElem1) (format_intro_array ElemType2 LenElem2) :-
        is_equal Length ElemType1 ElemType2,
        is_equal Length LenElem1 LenElem2.
    is_equal Length (format_intro_pair FirstType1 Closure1) (format_intro_pair FirstType2 Closure2) :-
        is_equal Length FirstType1 FirstType2,
        apply Closure1 (neutral (local Length)) SecondType1,
        apply Closure2 (neutral (local Length)) SecondType2,
        plus Length 1 Length1,
        is_equal Length1 SecondType1 SecondType2.

%end.
