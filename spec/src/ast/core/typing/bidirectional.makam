% Bidirectional Typing
%
% This section provides an operational semantics for the declarative
% typing rules in `core.typing.declarative`, and thus is intended to be
% a refinement of these rules. This means that some terms that are
% well-formed with respect to the declarative typing rules may _not_ be
% well-formed in the bidirectional typing rules, requiring additional
% type annotations in order to be considered valid.

%extend bidirectional.

    % FIXME: somehow import `semantics.(value, neutral, closure)` in
    % order to make this module a bit less verbose. See this comment for
    % more information: https://github.com/astampoulis/makam/issues/88#issuecomment-620318340


    % Bidirectional typing context.
    %
    % This stores the values and types of the bindings we have currently
    % traversed over, allowing us to evaluate terms and synthesize the
    % types of variables when we encounter them, and evaluate term.
    context : type.

    context : list (semantics.value * semantics.value) -> context.

    %extend context.

        values : context -> list semantics.value -> prop.
        values (context Entries) Values :-
            map tuple.fst Entries Values.


        lookup_type : context -> int -> semantics.value -> prop.
        lookup_type (context Entries) Index Type :-
            list.nth Entries Index (_, Type).


        next_local : context -> semantics.value -> prop.
        next_local (context Entries) (semantics.neutral (semantics.local Level)) :-
            length Entries Level.


        add_local : context -> semantics.value -> semantics.value -> context -> prop.
        add_local (context Entries) Elem Type (context ((Elem, Type) :: Entries)).


        add_param : context -> semantics.value -> context -> prop.
        add_param Context Type Context' :-
            next_local Context LocalElem,
            add_local Context LocalElem Type Context'.


        eval : context -> term -> semantics.value -> prop.
        eval Context Elem Elem' :-
            values Context Values,
            semantics.eval Values Elem Elem'.


        is_equal : context -> semantics.value -> semantics.value -> prop.
        is_equal (context Entries) Elem1 Elem2 :-
            length Entries Length,
            semantics.is_equal Length Elem1 Elem2.

    %end.


    % Typing rules

    % Check that a term is a type in the current context.
    is_type : context -> term -> prop.
    % Check that a term is an element of the given type in the current context.
    check_type : context -> term -> semantics.value -> prop.
    % Synthesize the type of a given term in the current context.
    synth_type : context -> term -> semantics.value -> prop.

    % A note on modes
    %
    % Makam does not support mode declarations (like in Mercury), but if it did
    % we'd assign the following mode declarations to the above predicates:
    %
    % ```
    % is_type : in -> in -> semidet.
    % check_type : in -> in -> int -> semidet.
    % synth_type : in -> in -> out -> semidet.
    % ```

    % Conversion
    check_type Context Elem Type :-
        synth_type Context Elem Type',
        context.is_equal Context Type Type'.

    % Variables
    synth_type Context (local Index) Type :-
        context.lookup_type Context Index Type.

    % Annotated terms
    % FIXME: is_type?
    synth_type Context (ann Elem Type) Type' :-
        is_type Context Type,
        context.eval Context Type Type',
        check_type Context Elem Type'.

    % Universes
    is_type Context universe.

    % Functions
    is_type Context (function_type InputType OutputType) :-
        is_type Context InputType,
        context.eval Context InputType InputType',
        context.add_param Context InputType' Context',
        is_type Context' OutputType.
    synth_type Context (function_type InputType OutputType) semantics.universe :-
        is_type Context InputType,
        context.eval Context InputType InputType',
        context.add_param Context InputType' Context'.
        is_type Context' OutputType.
    check_type Context (function_intro OutputElem) (semantics.function_type InputType Closure) :-
        context.next_local Context LocalElem,
        semantics.apply Closure LocalElem OutputType,
        context.add_param Context InputType Context',
        check_type Context' OutputElem OutputType.
    synth_type Context (function_elim Elem InputElem) OutputType :-
        synth_type Context Elem (semantics.function_type InputType Closure),
        check_type Context InputElem InputType,
        context.eval Context InputElem InputElem',
        semantics.apply Closure InputElem' OutputType.

    % Pairs
    is_type Context (pair_type FirstType SecondType) :-
        check_type Context FirstType semantics.universe,
        context.eval Context FirstType FirstType',
        context.add_param Context FirstType' Context',
        check_type Context' SecondType semantics.universe.
    synth_type Context (pair_type FirstType SecondType) semantics.universe :-
        check_type Context FirstType semantics.universe,
        context.eval Context FirstType FirstType',
        context.add_param Context FirstType' Context',
        check_type Context' SecondType semantics.universe.
    check_type Context (pair_intro FirstElem SecondElem) (semantics.pair_type FirstType Closure) :-
        check_type Context FirstElem FirstType,
        context.eval Context FirstElem FirstElem',
        context.add_local Context FirstElem' FirstType Context',
        semantics.apply Closure FirstElem' SecondType,
        check_type Context' SecondElem SecondType.
    synth_type Context (pair_elim_first PairElem) FirstType :-
        synth_type Context PairElem (semantics.pair_type FirstType _).
    synth_type Context (pair_elim_second PairElem) SecondType :-
        synth_type Context PairElem (semantics.pair_type _ Closure),
        context.eval Context (pair_elim_first PairElem) FirstElem,
        semantics.apply Closure FirstElem SecondType.

    % Enumerations
    is_type Context (enum_type Labels).
    synth_type Context (enum_type Labels) semantics.universe.
    check_type Context (enum_intro Label) (semantics.enum_type Labels) :-
        set.member Labels Label _.
    check_type Context (enum_elim Clauses) (semantics.function_type (semantics.enum_type Labels) Closure) :-
        map.keys Clauses ClauseLabels,
        eqv Labels ClauseLabels,
        set.map (pfun Label => [Type Elem] (
            map.find Clauses Label Elem,
            semantics.apply Closure (semantics.enum_intro Label) Type,
            check_type Context Elem Type
        )) ClauseLabels.

    % Integers
    is_type Context int_type.
    synth_type Context int_type semantics.universe.
    synth_type Context (int_intro _) semantics.int_type.

    % Arrays
    is_type Context (array_type Type LenElem) :-
        check_type Context Type semantics.universe,
        check_type Context LenElem semantics.int_type.
    synth_type Context (array_type Type LenElem) semantics.universe :-
        check_type Context Type semantics.universe,
        check_type Context LenElem semantics.int_type.
    check_type Context (array_intro Elems) (semantics.array_type Type (semantics.int_intro Len)) :-
        length Elems Len,
        map (fun elem => check_type Context elem Type) Elems.
    synth_type Context (array_elim ArrayElem IndexElem) Type :-
        % FIXME: ensure `IndexElem` is in array bounds, possibly with refinement types?
        synth_type Context ArrayElem (semantics.array_type Type _),
        check_type Context IndexElem semantics.int_type.

    % Binary format descriptions
    is_type Context format_type.
    synth_type Context format_intro_void semantics.format_type.
    synth_type Context format_intro_unit semantics.format_type.
    synth_type Context format_intro_u8 semantics.format_type.
    synth_type Context format_intro_u16le semantics.format_type.
    synth_type Context format_intro_u16be semantics.format_type.
    synth_type Context format_intro_u32le semantics.format_type.
    synth_type Context format_intro_u32be semantics.format_type.
    synth_type Context format_intro_u64le semantics.format_type.
    synth_type Context format_intro_u64be semantics.format_type.
    synth_type Context format_intro_s8 semantics.format_type.
    synth_type Context format_intro_s16le semantics.format_type.
    synth_type Context format_intro_s16be semantics.format_type.
    synth_type Context format_intro_s32le semantics.format_type.
    synth_type Context format_intro_s32be semantics.format_type.
    synth_type Context format_intro_s64le semantics.format_type.
    synth_type Context format_intro_s64be semantics.format_type.
    synth_type Context (format_intro_array Type LenElem) semantics.format_type :-
        check_type Context Type semantics.format_type,
        check_type Context LenElem semantics.int_type.
    synth_type Context (format_intro_pair FirstType SecondType) semantics.format_type :-
        check_type Context FirstType semantics.format_type,
        context.eval Context (format_elim FirstType) FirstType',
        context.add_param Context FirstType' Context',
        check_type Context' SecondType semantics.format_type.
    is_type Context (format_elim Type) :-
        check_type Context Type semantics.format_type.
    synth_type Context (format_elim Type) semantics.universe :-
        check_type Context Type semantics.format_type.


    % Convenience predicates

    is_type : term -> prop.
    is_type Elem :-
        is_type (context []) Elem.

    synth_type : term -> semantics.value -> prop.
    synth_type Elem Type :-
        synth_type (context []) Elem Type.

    check_type : term -> semantics.value -> prop.
    check_type Elem Type :-
        check_type (context []) Elem Type.

%end.
