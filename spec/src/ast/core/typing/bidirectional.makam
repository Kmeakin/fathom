% Bidirectional Typing
%
% This section provides an operational semantics for the declarative
% typing rules in `core.typing.declarative`, and thus is intended to be
% a refinement of these rules. This means that some terms that are
% well-formed with respect to the declarative typing rules may _not_ be
% well-formed in the bidirectional typing rules, requiring additional
% type annotations in order to be considered valid.

%extend bidirectional.

    %open fathom.ast.core.semantics.


    % Bidirectional typing context.
    %
    % This stores the values and types of the bindings we have currently
    % traversed over, allowing us to evaluate terms and synthesize the
    % types of variables when we encounter them, and evaluate term.
    context : type.

    context : list (value * value) -> context.

    %extend context.

        values : context -> list value -> prop.
        values (context Entries) Values :-
            map tuple.fst Entries Values.


        lookup_type : context -> int -> value -> prop.
        lookup_type (context Entries) Index Type :-
            list.nth Entries Index (_, Type).


        next_local : context -> value -> prop.
        next_local (context Entries) (neutral (local Level)) :-
            length Entries Level.


        add_local : context -> value -> value -> context -> prop.
        add_local (context Entries) Elem Type (context ((Elem, Type) :: Entries)).


        add_param : context -> value -> context -> prop.
        add_param Context Type Context' :-
            next_local Context LocalElem,
            add_local Context LocalElem Type Context'.


        eval : context -> term -> value -> prop.
        eval Context Elem Elem' :-
            values Context Values,
            eval Values Elem Elem'.


        is_equal : context -> value -> value -> prop.
        is_equal (context Entries) Elem1 Elem2 :-
            length Entries Length,
            is_equal Length Elem1 Elem2.

    %end.


    % Typing rules

    % Check that a term is a type in the current context.
    is_type : context -> term -> prop.
    % Check that a term is an element of the given type in the current context.
    check_type : context -> term -> value -> prop.
    % Synthesize the type of a given term in the current context.
    synth_type : context -> term -> value -> prop.

    % A note on modes
    %
    % Makam does not support mode declarations (like in Mercury), but if it did
    % we'd assign the following mode declarations to the above predicates:
    %
    % ```
    % is_type : in -> in -> semidet.
    % check_type : in -> in -> int -> semidet.
    % synth_type : in -> in -> out -> semidet.
    % ```

    % Conversion
    check_type Context Elem Type :-
        synth_type Context Elem Type',
        context.is_equal Context Type Type'.

    % Variables
    synth_type Context (local Index) Type :-
        context.lookup_type Context Index Type.

    % Annotated terms
    synth_type Context (ann Elem Type) Type' :-
        is_type Context Type,
        context.eval Context Type Type',
        check_type Context Elem Type'.

    % Universes
    is_type Context type_type.

    % Functions
    is_type Context (function_type InputType OutputType) :-
        is_type Context InputType,
        context.eval Context InputType InputType',
        context.add_param Context InputType' Context',
        is_type Context' OutputType.
    synth_type Context (function_type InputType OutputType) type_type :-
        is_type Context InputType,
        context.eval Context InputType InputType',
        context.add_param Context InputType' Context'.
        is_type Context' OutputType.
    check_type Context (function_intro OutputElem) (function_type InputType Closure) :-
        context.next_local Context LocalElem,
        apply Closure LocalElem OutputType,
        context.add_param Context InputType Context',
        check_type Context' OutputElem OutputType.
    synth_type Context (function_elim Elem InputElem) OutputType :-
        synth_type Context Elem (function_type InputType Closure),
        check_type Context InputElem InputType,
        context.eval Context InputElem InputElem',
        apply Closure InputElem' OutputType.

    % Pairs
    is_type Context (pair_type FirstType SecondType) :-
        check_type Context FirstType type_type,
        context.eval Context FirstType FirstType',
        context.add_param Context FirstType' Context',
        check_type Context' SecondType type_type.
    synth_type Context (pair_type FirstType SecondType) type_type :-
        check_type Context FirstType type_type,
        context.eval Context FirstType FirstType',
        context.add_param Context FirstType' Context',
        check_type Context' SecondType type_type.
    check_type Context (pair_intro FirstElem SecondElem) (pair_type FirstType Closure) :-
        check_type Context FirstElem FirstType,
        context.eval Context FirstElem FirstElem',
        context.add_local Context FirstElem' FirstType Context',
        apply Closure FirstElem' SecondType,
        check_type Context' SecondElem SecondType.
    synth_type Context (pair_elim_first PairElem) FirstType :-
        synth_type Context PairElem (pair_type FirstType _).
    synth_type Context (pair_elim_second PairElem) SecondType :-
        synth_type Context PairElem (pair_type _ Closure),
        context.eval Context (pair_elim_first PairElem) FirstElem,
        apply Closure FirstElem SecondType.

    % Records
    is_type Context (record_type []).
    is_type Context (record_type ((Label, Type) :: TypeFields)) :-
        not (contains (Label, _) TypeFields),
        check_type Context Type type_type,
        context.eval Context Type Type',
        context.add_param Context Type' Context',
        is_type Context (record_type TypeFields).
    synth_type Context (record_type []) type_type.
    synth_type Context (record_type ((Label, Type) :: TypeFields)) type_type :-
        not (contains (Label, _) TypeFields),
        check_type Context Type type_type,
        context.eval Context Type Type',
        context.add_param Context Type' Context',
        check_type Context' (record_type TypeFields) type_type.
    check_type Context (record_intro []) (record_type (field_closure Values [])).
    check_type
        Context
        (record_intro ElemFields)
        (record_type (field_closure Values ((Label, Type) :: TypeFields)))
    :-
        map.remove ElemFields Label Elem ElemFields',
        eval Values Type Type',
        check_type Context Elem Type',
        context.eval Context Elem Elem',
        context.add_local Context Elem' Type' Context',
        eq FieldClosure (field_closure (Elem' :: Values) TypeFields),
        check_type Context' (record_intro ElemFields') (record_type FieldClosure).
    synth_type Context (record_elim RecordElem Label) FieldType :-
        synth_type Context RecordElem (record_type FieldClosure),
        context.eval Context RecordElem RecordElem',
        record_elim_type RecordElem' Label FieldClosure FieldType.

    % Enumerations
    is_type Context (enum_type Labels).
    synth_type Context (enum_type Labels) type_type.
    check_type Context (enum_intro Label) (enum_type Labels) :-
        set.member Labels Label _.
    check_type Context (enum_elim Clauses) (function_type (enum_type Labels) Closure) :-
        map.keys Clauses ClauseLabels,
        eqv Labels ClauseLabels,
        set.map (pfun Label => [Type Elem] (
            map.find Clauses Label Elem,
            apply Closure (enum_intro Label) Type,
            check_type Context Elem Type
        )) ClauseLabels.

    % Integers
    is_type Context int_type.
    synth_type Context int_type type_type.
    synth_type Context (int_intro _) int_type.

    % Arrays
    is_type Context (array_type Type LenElem) :-
        check_type Context Type type_type,
        check_type Context LenElem int_type.
    synth_type Context (array_type Type LenElem) type_type :-
        check_type Context Type type_type,
        check_type Context LenElem int_type.
    check_type Context (array_intro Elems) (array_type Type (int_intro Len)) :-
        length Elems Len,
        map (fun elem => check_type Context elem Type) Elems.
    synth_type Context (array_elim ArrayElem IndexElem) Type :-
        % FIXME: ensure `IndexElem` is in array bounds, possibly with refinement types?
        synth_type Context ArrayElem (array_type Type _),
        check_type Context IndexElem int_type.

    % Binary format descriptions
    is_type Context format_type.
    synth_type Context format_intro_void format_type.
    synth_type Context format_intro_unit format_type.
    synth_type Context format_intro_u8 format_type.
    synth_type Context format_intro_u16le format_type.
    synth_type Context format_intro_u16be format_type.
    synth_type Context format_intro_u32le format_type.
    synth_type Context format_intro_u32be format_type.
    synth_type Context format_intro_u64le format_type.
    synth_type Context format_intro_u64be format_type.
    synth_type Context format_intro_s8 format_type.
    synth_type Context format_intro_s16le format_type.
    synth_type Context format_intro_s16be format_type.
    synth_type Context format_intro_s32le format_type.
    synth_type Context format_intro_s32be format_type.
    synth_type Context format_intro_s64le format_type.
    synth_type Context format_intro_s64be format_type.
    synth_type Context (format_intro_array Type LenElem) format_type :-
        check_type Context Type format_type,
        check_type Context LenElem int_type.
    synth_type Context (format_intro_pair FirstType SecondType) format_type :-
        check_type Context FirstType format_type,
        context.eval Context (format_elim FirstType) FirstType',
        context.add_param Context FirstType' Context',
        check_type Context' SecondType format_type.
    synth_type Context (format_intro_record []) format_type.
    synth_type Context (format_intro_record ((Label, Type) :: TypeFields)) format_type :-
        not (contains (Label, _) TypeFields),
        check_type Context Type format_type,
        context.eval Context (format_elim Type) Type',
        context.add_param Context Type' Context',
        check_type Context' (format_intro_record TypeFields) format_type.
    synth_type Context (format_intro_compute Elem Type) format_type :-
        is_type Context Type,
        context.eval Context Type Type',
        check_type Context Elem Type'.
    synth_type Context (format_intro_absorb Type) format_type :-
        check_type Context Type format_type.
    is_type Context (format_elim Type) :-
        check_type Context Type format_type.
    synth_type Context (format_elim Type) type_type :-
        check_type Context Type format_type.


    % Convenience predicates

    is_type : term -> prop.
    is_type Elem :-
        is_type (context []) Elem.

    synth_type : term -> value -> prop.
    synth_type Elem Type :-
        synth_type (context []) Elem Type.

    check_type : term -> value -> prop.
    check_type Elem Type :-
        check_type (context []) Elem Type.

%end.
