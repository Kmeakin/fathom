stdout = '''
let id : fun (A : Type) -> A -> A = fun _ => fun a => a;
let always : fun (A : Type) -> fun (B : Type) -> A -> B -> A =
fun _ => fun _ => fun a => fun _ => a;
let compose : fun (A : Type) -> fun (B : Type) -> fun (C : Type) -> (A -> B) ->
(B -> C) -> A -> C =
fun _ => fun _ => fun _ => fun ab => fun bc => fun a => bc (ab a);
let Nat : Type = fun (Nat : _) -> (Nat -> Nat) -> Nat -> Nat;
let zero : fun (Nat : Type) -> (Nat -> Nat) -> Nat -> Nat =
fun Nat => fun succ => fun zero => zero;
let succ : (fun (Nat : Type) -> (Nat -> Nat) -> Nat -> Nat) -> fun (Nat :
Type) -> (Nat -> Nat) -> Nat -> Nat =
fun prev => fun Nat => fun succ => fun zero => succ (prev (_ prev Nat succ zero) succ zero);
let add : (fun (Nat : Type) -> (Nat -> Nat) -> Nat -> Nat) -> (fun (Nat :
Type) -> (Nat -> Nat) -> Nat -> Nat) -> fun (Nat : Type) -> (Nat -> Nat) -> Nat
-> Nat =
fun n0 => fun n1 => fun Nat => fun succ => fun zero => n0 Nat succ (n1 Nat succ zero);
let mul : (fun (Nat : Type) -> (Nat -> Nat) -> Nat -> Nat) -> (fun (Nat :
Type) -> (Nat -> Nat) -> Nat -> Nat) -> fun (Nat : Type) -> (Nat -> Nat) -> Nat
-> Nat =
fun n0 => fun n1 => fun Nat => fun succ => fun zero => n0 Nat (n1 Nat succ) zero;
let List : Type -> Type = fun Elem => fun (List : _ Elem) -> List -> (Elem ->
List -> List) -> List;
let nil : fun (Elem : Type) -> fun (List : Type) -> List -> (Elem -> List ->
List) -> List = fun Elem => fun List => fun nil => fun cons => nil;
let cons : fun (Elem : Type) -> Elem -> (fun (List : Type) -> List -> (Elem ->
List -> List) -> List) -> fun (List : Type) -> List -> (Elem -> List -> List) ->
List =
fun Elem => fun head => fun tail => fun List => fun nil => fun cons => cons head (tail (_ Elem head tail List nil cons) nil cons);
let Vec : Type -> (fun (Nat : Type) -> (Nat -> Nat) -> Nat -> Nat) -> Type =
fun Elem => fun len => fun (Vec : (fun (Nat : Type) -> (Nat -> Nat) -> Nat ->
Nat) -> Type) -> Vec (fun Nat => fun succ => fun zero => zero) -> (fun (len :
fun (Nat : Type) -> (Nat -> Nat) -> Nat -> Nat) -> Elem -> Vec len ->
Vec (fun Nat => fun succ => fun zero => succ (len Nat succ zero))) -> Vec len;
let vnil : fun (Elem : Type) -> fun (Vec : (fun (Nat : Type) -> (Nat -> Nat) ->
Nat -> Nat) -> Type) -> Vec (fun Nat => fun succ => fun zero => zero) ->
(fun (len : fun (Nat : Type) -> (Nat -> Nat) -> Nat -> Nat) -> Elem -> Vec len
-> Vec (fun Nat => fun succ => fun zero => succ (len Nat succ zero))) ->
Vec (fun Nat => fun succ => fun zero => zero) =
fun Elem => fun Vec => fun nil => fun cons => nil;
let vcons : fun (Elem : Type) -> fun (len : fun (Nat : Type) -> (Nat -> Nat) ->
Nat -> Nat) -> Elem -> (fun (Vec : (fun (Nat : Type) -> (Nat -> Nat) -> Nat ->
Nat) -> Type) -> Vec (fun Nat => fun succ => fun zero => zero) -> (fun (len :
fun (Nat : Type) -> (Nat -> Nat) -> Nat -> Nat) -> Elem -> Vec len ->
Vec (fun Nat => fun succ => fun zero => succ (len Nat succ zero))) -> Vec len)
-> fun (Vec : (fun (Nat : Type) -> (Nat -> Nat) -> Nat -> Nat) -> Type) ->
Vec (fun Nat => fun succ => fun zero => zero) -> (fun (len : fun (Nat : Type) ->
(Nat -> Nat) -> Nat -> Nat) -> Elem -> Vec len ->
Vec (fun Nat => fun succ => fun zero => succ (len Nat succ zero))) ->
Vec (fun Nat => fun succ => fun zero => succ (len Nat succ zero)) =
fun Elem => fun len => fun head => fun tail => fun Vec => fun nil => fun cons => cons (_ Elem len head tail Vec nil cons) head (tail Vec nil cons);
let Void : Type = fun (Void : Type) -> Void;
let absurd : fun (A : Type) -> (fun (Void : Type) -> Void) -> A =
fun A => fun void => void A;
let Unit : Type = fun (Unit : Type) -> Unit -> Unit;
let unit : fun (Unit : Type) -> Unit -> Unit = fun Unit => fun unit => unit;
let Eq : fun (A : Type) -> A -> A -> Type =
fun A => fun a0 => fun a1 => fun (P : A -> Type) -> P a0 -> P a1;
let refl : fun (A : Type) -> fun (a : A) -> fun (P : A -> Type) -> P a -> P a =
fun A => fun a => fun P => id (P a);
let trans : fun (A : Type) -> fun (a0 : A) -> fun (a1 : A) -> fun (a2 : A) ->
(fun (P : A -> Type) -> P a0 -> P a1) -> (fun (P : A -> Type) -> P a1 -> P a2)
-> fun (P : A -> Type) -> P a0 -> P a2 =
fun _ => fun a0 => fun a1 => fun a2 => fun p0 => fun p1 => fun P => compose (_ _ a0 a1 a2 p0 p1 P) (_ _ a0 a1 a2 p0 p1 P) (_ _ a0 a1 a2 p0 p1 P) (p0 P) (p1 P);
let sym : fun (A : Type) -> fun (a0 : A) -> fun (a1 : A) -> (fun (P : A ->
Type) -> P a0 -> P a1) -> fun (P : A -> Type) -> P a1 -> P a0 =
fun _ => fun a0 => fun a1 => fun p => p (fun a1 => Eq (_ _ a0 a1 p a1) a1 a0) (refl (_ _ a0 a1 p) (_ _ a0 a1 p));
let id_apply_type : _ = (fun a => a) Type;
let list1 : fun (List : Type) -> List -> (Bool -> List -> List) -> List =
cons _ (id _ true) (nil _);
let five : fun (Nat : Type) -> (Nat -> Nat) -> Nat -> Nat =
succ (succ (succ (succ (succ zero))));
let ten : fun (Nat : Type) -> (Nat -> Nat) -> Nat -> Nat = add five five;
let hundred : fun (Nat : Type) -> (Nat -> Nat) -> Nat -> Nat = mul ten ten;
let thousand : fun (Nat : Type) -> (Nat -> Nat) -> Nat -> Nat = mul ten hundred;
let eq_test : fun (P : (fun (Nat : Type) -> (Nat -> Nat) -> Nat -> Nat) ->
Type) ->
P (fun Nat => fun succ => fun zero => succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ zero))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
->
P (fun Nat => fun succ => fun zero => succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) =
refl _ _;
let eq_id_apply_type : fun (P : Type -> Type) -> P Type -> P Type = refl _ _;
let eq_id_apply_true : fun (P : Bool -> Type) -> P true -> P true = refl _ _;
let eq_id_apply_false : fun (P : Bool -> Type) -> P false -> P false = refl _ _;
Type : Type
'''
stderr = ''
