use codespan::FileId;
use codespan_reporting::diagnostic::Diagnostic;
use std::borrow::Cow;
use std::io;
use std::io::prelude::*;

use crate::core;

pub fn compile_module(
    writer: &mut impl Write,
    module: &core::Module,
    report: &mut dyn FnMut(Diagnostic),
) -> io::Result<()> {
    let context = ModuleContext {
        _file_id: module.file_id,
    };

    let pkg_name = env!("CARGO_PKG_NAME");
    let pkg_version = env!("CARGO_PKG_VERSION");

    write!(
        writer,
        "\
<!--
  This file is automatically @generated by {pkg_name} {pkg_version}
  It is not intended for manual editing.
-->

<!DOCTYPE html>
<html lang=\"en\">
<head>
  <meta charset=\"UTF-8\">
  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">
  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">
  <title>{module_name}</title>
</head>
<body>
  <dl class=\"module\">
",
        module_name = "", // TODO: module name
        pkg_name = pkg_name,
        pkg_version = pkg_version,
    )?;

    for item in &module.items {
        match item {
            core::Item::Alias(alias) => compile_alias(&context, writer, alias, report)?,
            core::Item::Struct(struct_ty) => {
                compile_struct_ty(&context, writer, struct_ty, report)?
            }
        }
    }

    write!(
        writer,
        "\
  </dl>
</body>
"
    )?;

    Ok(())
}

struct ModuleContext {
    _file_id: FileId,
}

fn compile_alias(
    context: &ModuleContext,
    writer: &mut impl Write,
    alias: &core::Alias,
    report: &mut dyn FnMut(Diagnostic),
) -> io::Result<()> {
    writeln!(writer, "    <dt class=\"item alias\">")?;
    writeln!(writer, "      <a href=\"#\">{}</a>", alias.name)?;
    writeln!(writer, "    </dt>")?;
    writeln!(writer, "    <dd class=\"item alias\">")?;

    if !alias.doc.is_empty() {
        compile_doc_lines(writer, "      ", &alias.doc)?;
    }

    let term = compile_term(context, &alias.term, report);

    writeln!(writer, "      <div>")?;
    writeln!(writer, "        {}", term)?;
    writeln!(writer, "      </div>")?;
    writeln!(writer, "    </dd>")?;

    Ok(())
}

fn compile_struct_ty(
    context: &ModuleContext,
    writer: &mut impl Write,
    struct_ty: &core::StructType,
    report: &mut dyn FnMut(Diagnostic),
) -> io::Result<()> {
    writeln!(writer, "    <dt class=\"item struct\">")?;
    writeln!(writer, "      struct <a href=\"#\">{}</a>", struct_ty.name)?;
    writeln!(writer, "    </dt>")?;
    writeln!(writer, "    <dd class=\"item struct\">")?;

    if !struct_ty.doc.is_empty() {
        compile_doc_lines(writer, "      ", &struct_ty.doc)?;
    }

    if !struct_ty.fields.is_empty() {
        writeln!(writer, "    <dl class=\"fields\">")?;
        for field in &struct_ty.fields {
            let ty = compile_term(context, &field.term, report);

            writeln!(writer, "      <dt class=\"field\">")?;
            writeln!(writer, "        <a href=\"#\">{}</a> : {}", field.name, ty)?;
            writeln!(writer, "      </dt>")?;
            writeln!(writer, "      <dd class=\"field\">")?;
            compile_doc_lines(writer, "        ", &field.doc)?;
            writeln!(writer, "      </dd>")?;
        }
        writeln!(writer, "    </dl>")?;
    }

    writeln!(writer, "    </dd>")?;

    Ok(())
}

fn compile_term<'term>(
    context: &ModuleContext,
    term: &'term core::Term,
    report: &mut dyn FnMut(Diagnostic),
) -> Cow<'term, str> {
    match term {
        // TODO: Link to specific docs
        core::Term::Item(_, name) => format!("<var><a href=\"#\">{}</a></var>", name).into(),
        core::Term::Ann(term, ty) => {
            let term = compile_term(context, term, report);
            let ty = compile_term(context, ty, report);

            format!("{} : {}", term, ty).into()
        }
        // TODO: Link to global docs
        core::Term::Kind(_) => "<var><a href=\"#\">Kind</a></var>".into(),
        core::Term::Type(_) => "<var><a href=\"#\">Type</a></var>".into(),
        core::Term::U8Type(_) => "<var><a href=\"#\">U8</a></var>".into(),
        core::Term::U16LeType(_) => "<var><a href=\"#\">U16Le</a></var>".into(),
        core::Term::U16BeType(_) => "<var><a href=\"#\">U16Be</a></var>".into(),
        core::Term::U32LeType(_) => "<var><a href=\"#\">U32Le</a></var>".into(),
        core::Term::U32BeType(_) => "<var><a href=\"#\">U32Be</a></var>".into(),
        core::Term::U64LeType(_) => "<var><a href=\"#\">U64Le</a></var>".into(),
        core::Term::U64BeType(_) => "<var><a href=\"#\">U64Be</a></var>".into(),
        core::Term::S8Type(_) => "<var><a href=\"#\">S8</a></var>".into(),
        core::Term::S16LeType(_) => "<var><a href=\"#\">S16Le</a></var>".into(),
        core::Term::S16BeType(_) => "<var><a href=\"#\">S16Be</a></var>".into(),
        core::Term::S32LeType(_) => "<var><a href=\"#\">S32Le</a></var>".into(),
        core::Term::S32BeType(_) => "<var><a href=\"#\">S32Be</a></var>".into(),
        core::Term::S64LeType(_) => "<var><a href=\"#\">S64Le</a></var>".into(),
        core::Term::S64BeType(_) => "<var><a href=\"#\">S64Be</a></var>".into(),
        core::Term::F32LeType(_) => "<var><a href=\"#\">F32Le</a></var>".into(),
        core::Term::F32BeType(_) => "<var><a href=\"#\">F32Be</a></var>".into(),
        core::Term::F64LeType(_) => "<var><a href=\"#\">F64Le</a></var>".into(),
        core::Term::F64BeType(_) => "<var><a href=\"#\">F64Be</a></var>".into(),
        core::Term::BoolType(_) => "<var><a href=\"#\">Bool</a></var>".into(), // NOTE: Invalid if in struct
        core::Term::IntType(_) => "<var><a href=\"#\">Int</a></var>".into(), // NOTE: Invalid if in struct
        core::Term::F32Type(_) => "<var><a href=\"#\">F32</a></var>".into(), // NOTE: Invalid if in struct
        core::Term::F64Type(_) => "<var><a href=\"#\">F64</a></var>".into(), // NOTE: Invalid if in struct
        core::Term::BoolConst(_, true) => "<var><a href=\"#\">true</a></var>".into(), // TODO: Invalid if in type
        core::Term::BoolConst(_, false) => "<var><a href=\"#\">false</a></var>".into(), // TODO: Invalid if in type
        core::Term::F32Const(_, value) => format!("{}", value).into(), // TODO: Invalid if in type
        core::Term::F64Const(_, value) => format!("{}", value).into(), // TODO: Invalid if in type
        core::Term::IntConst(_, value) => format!("{}", value).into(), // TODO: Invalid if in type
        core::Term::Error(_) => "<strong>(invalid data description)</strong>".into(),
    }
}

fn compile_doc_lines(
    writer: &mut impl Write,
    prefix: &str,
    doc_lines: &[String],
) -> io::Result<()> {
    // TODO: parse markdown

    for doc_line in doc_lines.iter() {
        let doc_line = match doc_line {
            line if line.starts_with(" ") => &line[" ".len()..],
            line => &line[..],
        };
        writeln!(writer, "{}{}", prefix, doc_line)?;
    }

    Ok(())
}
