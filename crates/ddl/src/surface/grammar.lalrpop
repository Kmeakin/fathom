use codespan_reporting::diagnostic::Diagnostic;
use std::ops::Range;
use std::sync::Arc;

use crate::surface::{Alias, Item, Module, Pattern, StructType, Term, TypeField};
use crate::lexer::Token;
use crate::literal;

grammar(file_id: usize, report: &mut dyn FnMut(Diagnostic<usize>));

extern {
    type Location = usize;
    type Error = Diagnostic<usize>;

    enum Token {
        "doc comment" => Token::DocComment(<String>),
        "inner doc comment" => Token::InnerDocComment(<String>),
        "identifier" => Token::Identifier(<String>),
        "numeric literal" => Token::NumberLiteral(<literal::Number>),
        "string literal" => Token::StringLiteral(<literal::String>),
        "character literal" => Token::CharLiteral(<literal::Char>),

        "bool_elim" => Token::BoolElim,
        "else" => Token::Else,
        "f32" => Token::F32,
        "f64" => Token::F64,
        "Format" => Token::Format,
        "global" => Token::Global,
        "Host" => Token::Host,
        "if" => Token::If,
        "int" => Token::Int,
        "int_elim" => Token::IntElim,
        "item" => Token::Item,
        "Kind" => Token::Kind,
        "match" => Token::Match,
        "struct" => Token::Struct,

        "{" => Token::OpenBrace,
        "}" => Token::CloseBrace,
        "(" => Token::OpenParen,
        ")" => Token::CloseParen,

        "!" => Token::Bang,
        ":" => Token::Colon,
        "," => Token::Comma,
        "=" => Token::Equals,
        "=>" => Token::EqualsGreater,
        "->" => Token::HyphenGreater,
        ";" => Token::Semi,
    }
}

pub Module: Module = {
    <doc: "inner doc comment"*>
    <items: Item*> => {
        let doc = Arc::from(doc);

        Module { file_id, doc, items }
    },
};

Item: Item = {
    <doc: "doc comment"*>
    <start: @L> <name: Identifier> <ty: (":" <Term>)?> "=" <term: Term> ";" <end: @R> => {
        let range = start..end;
        let doc = Arc::from(doc);

        Item::Alias(Alias { range, doc, name, ty, term })
    },
    <doc: "doc comment"*>
    <start: @L> "struct" <name: Identifier> "{"
        <mut fields: (<Field> ",")*>
        <last: Field?>
    "}" <end: @R> => {
        let range = start..end;
        let doc = Arc::from(doc);
        fields.extend(last);

        Item::Struct(StructType { range, doc, name, fields })
    },
};

Field: TypeField = {
    <docs: "doc comment"*>
    <name: Identifier> ":" <term: Term> => {
        TypeField { doc: Arc::from(docs), name, term }
    },
};

Pattern: Pattern = {
    <name: Identifier> => Pattern::Name(name.0, name.1),
    <start: @L> <literal: "numeric literal"> <end: @R> => {
        Pattern::NumberLiteral(start..end, literal)
    },
};

Term: Term = {
    ArrowTerm,
    <term: ArrowTerm> ":" <ty: Term> => Term::Ann(Box::new(term), Box::new(ty)),
};

ArrowTerm: Term = {
    AppTerm,
    <param_type: AppTerm> "->" <body_type: ArrowTerm> => {
        Term::FunctionType(Box::new(param_type), Box::new(body_type))
    },
};

AppTerm: Term = {
    AtomicTerm,
    <head: AtomicTerm> <arguments: AtomicTerm+> => {
        Term::FunctionElim(Box::new(head), arguments)
    },
};

AtomicTerm: Term = {
    "(" <term: Term> ")" => term,
    <name: Identifier> => Term::Name(name.0, name.1),
    <start: @L> "Host" <end: @R> => Term::Host(start..end),
    <start: @L> "Format" <end: @R> => Term::Format(start..end),
    <start: @L> "Kind" <end: @R> => Term::Kind(start..end),
    <start: @L> <literal: "numeric literal"> <end: @R> => {
        Term::NumberLiteral(start..end, literal)
    },
    <start: @L> "if" <head: Term> "{" <if_true: Term> "}" "else" "{" <if_false: Term> "}" <end: @R> => {
        Term::If(start..end, Box::new(head), Box::new(if_true), Box::new(if_false))
    },
    <start: @L> "match" <head: Term> "{" <mut branches: (<Pattern> "=>" <Term> ",")*> <last: (<Pattern> "=>" <Term>)?>"}" <end: @R> => {
        branches.extend(last);
        Term::Match(start..end, Box::new(head), branches)
    },
};

Identifier: (Range<usize>, String) = {
    <start: @L> <name: "identifier"> <end: @R> => {
        (start..end, name)
    },
};
