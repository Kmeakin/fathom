use codespan::FileId;
use codespan_reporting::diagnostic::Diagnostic;
use std::borrow::Cow;
use std::collections::HashMap;
use std::io;
use std::io::prelude::*;

use crate::surface;

pub fn compile_module(
    writer: &mut impl Write,
    module: &surface::Module,
    report: &mut dyn FnMut(Diagnostic),
) -> io::Result<()> {
    let mut context = ModuleContext {
        _file_id: module.file_id,
        items: HashMap::new(),
    };

    write!(
        writer,
        r##"<!--
  This file is automatically @generated by {pkg_name} {pkg_version}
  It is not intended for manual editing.
-->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>{module_name}</title>
    <style>
{minireset}

{style}
    </style>
  </head>
  <body>
    <section class="module">
"##,
        pkg_name = env!("CARGO_PKG_NAME"),
        pkg_version = env!("CARGO_PKG_VERSION"),
        module_name = "", // TODO: module name
        minireset = include_str!("./minireset.min.css").trim(),
        style = include_str!("./style.css").trim(),
    )?;

    if !module.doc.is_empty() {
        writeln!(writer, r##"      <section class="doc">"##)?;
        compile_doc_lines(writer, "        ", &module.doc)?;
        writeln!(writer, r##"      </section>"##)?;
    }

    writeln!(writer, r##"      <dl class="items">"##)?;

    for item in &module.items {
        let (label, item) = match item {
            surface::Item::Alias(alias) => compile_alias(&context, writer, alias, report)?,
            surface::Item::Struct(struct_ty) => {
                compile_struct_ty(&context, writer, struct_ty, report)?
            }
        };

        context.items.insert(label, item);
    }

    write!(
        writer,
        r##"      </dl>
    </section>
  </body>
</html>
"##
    )?;

    Ok(())
}

struct ModuleContext {
    _file_id: FileId,
    items: HashMap<String, Item>,
}

struct Item {
    id: String,
}

fn compile_alias(
    context: &ModuleContext,
    writer: &mut impl Write,
    alias: &surface::Alias,
    report: &mut dyn FnMut(Diagnostic),
) -> io::Result<(String, Item)> {
    let (_, name) = &alias.name;
    let id = format!("items[{}]", name);

    writeln!(
        writer,
        r##"        <dt id="{id}" class="item alias">"##,
        id = id,
    )?;
    match &alias.ty {
        None => writeln!(
            writer,
            r##"          <a href="#{id}">{name}</a>"##,
            id = id,
            name = name,
        )?,
        Some(ty) => writeln!(
            writer,
            r##"          <a href="#{id}">{name}</a> : {ty}"##,
            id = id,
            name = name,
            ty = compile_term(context, ty, report),
        )?,
    }
    write!(
        writer,
        r##"        </dt>
        <dd class="item alias">
"##
    )?;

    if !alias.doc.is_empty() {
        writeln!(writer, r##"          <section class="doc">"##)?;
        compile_doc_lines(writer, "            ", &alias.doc)?;
        writeln!(writer, r##"          </section>"##)?;
    }

    let term = compile_term(context, &alias.term, report);

    write!(
        writer,
        r##"          <section class="term">
            {}
          </section>
        </dd>
"##,
        term
    )?;

    Ok((name.clone(), Item { id }))
}

fn compile_struct_ty(
    context: &ModuleContext,
    writer: &mut impl Write,
    struct_ty: &surface::StructType,
    report: &mut dyn FnMut(Diagnostic),
) -> io::Result<(String, Item)> {
    let (_, name) = &struct_ty.name;
    let id = format!("items[{}]", name);

    write!(
        writer,
        r##"        <dt id="{id}" class="item struct">
          struct <a href="#{id}">{name}</a>
        </dt>
        <dd class="item struct">
"##,
        id = id,
        name = name
    )?;

    if !struct_ty.doc.is_empty() {
        writeln!(writer, r##"          <section class="doc">"##)?;
        compile_doc_lines(writer, "            ", &struct_ty.doc)?;
        writeln!(writer, r##"          </section>"##)?;
    }

    if !struct_ty.fields.is_empty() {
        writeln!(writer, r##"          <dl class="fields">"##)?;
        for field in &struct_ty.fields {
            let (_, field_name) = &field.name;
            let field_id = format!("{}.fields[{}]", id, field_name);
            let ty = compile_term(context, &field.term, report);

            write!(
                writer,
                r##"            <dt id="{id}" class="field">
              <a href="#{id}">{name}</a> : {ty}
            </dt>
            <dd class="field">
              <section class="doc">
"##,
                id = field_id,
                name = field_name,
                ty = ty,
            )?;
            compile_doc_lines(writer, "                ", &field.doc)?;
            write!(
                writer,
                r##"              </section>
            </dd>
"##
            )?;
        }
        writeln!(writer, r##"          </dl>"##)?;
    }

    writeln!(writer, r##"        </dd>"##)?;

    Ok((name.clone(), Item { id }))
}

fn compile_term<'term>(
    context: &ModuleContext,
    term: &'term surface::Term,
    report: &mut dyn FnMut(Diagnostic),
) -> Cow<'term, str> {
    use itertools::Itertools;

    match term {
        surface::Term::Paren(_, term) => {
            format!("({})", compile_term(context, term, report)).into()
        }
        surface::Term::Name(_, name) => {
            let id = match context.items.get(name) {
                Some(item) => item.id.as_str(),
                None => "",
            };

            format!(r##"<var><a href="#{}">{}</a></var>"##, id, name).into()
        }
        surface::Term::Ann(term, ty) => {
            let term = compile_term(context, term, report);
            let ty = compile_term(context, ty, report);

            format!("{} : {}", term, ty).into()
        }
        surface::Term::NumberLiteral(_, literal) => format!("{}", literal).into(),
        surface::Term::If(_, head, if_true, if_false) => format!(
            // TODO: multiline formatting!
            "if {head} {{ {if_true} }} else {{ {if_false} }}",
            head = compile_term(context, head, report),
            if_true = compile_term(context, if_true, report),
            if_false = compile_term(context, if_false, report),
        )
        .into(),
        surface::Term::Match(_, head, branches) => format!(
            // TODO: multiline formatting!
            "match {head} {{ {branches} }}",
            head = compile_term(context, head, report),
            branches = branches
                .iter()
                .map(|(pattern, term)| format!(
                    "{pattern} => {term}",
                    pattern = compile_pattern(context, pattern),
                    term = compile_term(context, term, report),
                ))
                .format(","),
        )
        .into(),
        surface::Term::Error(_) => r##"<strong>(invalid data description)</strong>"##.into(),
    }
}

fn compile_pattern<'term>(
    _context: &ModuleContext,
    pattern: &'term surface::Pattern,
) -> Cow<'term, str> {
    match pattern {
        surface::Pattern::Name(_, name) => format!(r##"<a href="#">{}</a>"##, name).into(), // TODO: add local binding
        surface::Pattern::NumberLiteral(_, literal) => format!("{}", literal).into(),
    }
}

fn compile_doc_lines(
    writer: &mut impl Write,
    prefix: &str,
    doc_lines: &[String],
) -> io::Result<()> {
    // TODO: parse markdown

    for doc_line in doc_lines.iter() {
        let doc_line = match doc_line {
            line if line.starts_with(" ") => &line[" ".len()..],
            line => &line[..],
        };
        writeln!(writer, "{}{}", prefix, doc_line)?;
    }

    Ok(())
}
