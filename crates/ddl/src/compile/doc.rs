use std::io;
use std::io::prelude::*;

use crate::core;

pub fn compile_module(writer: &mut impl Write, module: &core::Module) -> io::Result<()> {
    let pkg_name = env!("CARGO_PKG_NAME");
    let pkg_version = env!("CARGO_PKG_VERSION");

    writeln!(writer, "<!--")?;
    writeln!(
        writer,
        "  This file is automatically @generated by {} {}",
        pkg_name, pkg_version,
    )?;
    writeln!(writer, "  It is not intended for manual editing.")?;
    writeln!(writer, "-->")?;

    for item in &module.items {
        writeln!(writer)?;
        match item {
            core::Item::Alias(alias) => compile_alias(writer, alias)?,
            core::Item::Struct(struct_ty) => compile_struct_ty(writer, struct_ty)?,
        }
    }

    Ok(())
}

fn compile_alias(writer: &mut impl Write, alias: &core::Alias) -> io::Result<()> {
    writeln!(writer, "## {}", alias.name)?;

    if !alias.doc.is_empty() {
        writeln!(writer)?;
        writeln!(writer, "### Description")?;
        writeln!(writer)?;
        for doc_line in alias.doc.iter() {
            // TODO: Bump inner heading levels
            let doc_line = match doc_line {
                line if line.starts_with(" ") => &line[" ".len()..],
                line => &line[..],
            };
            writeln!(writer, "{}", doc_line)?;
        }
    }

    writeln!(writer)?;
    writeln!(writer, "### Definition")?;
    writeln!(writer)?;
    writeln!(writer, "```")?;
    writeln!(writer, "{}", compile_ty(&alias.term))?;
    writeln!(writer, "```")?;

    Ok(())
}

fn compile_struct_ty(writer: &mut impl Write, struct_ty: &core::StructType) -> io::Result<()> {
    writeln!(writer, "## {}", struct_ty.name)?;

    if !struct_ty.doc.is_empty() {
        writeln!(writer)?;
        writeln!(writer, "### Description")?;
        writeln!(writer)?;
        for doc_line in struct_ty.doc.iter() {
            // TODO: Bump inner heading levels
            let doc_line = match doc_line {
                line if line.starts_with(" ") => &line[" ".len()..],
                line => &line[..],
            };
            writeln!(writer, "{}", doc_line)?;
        }
    }

    if !struct_ty.fields.is_empty() {
        writeln!(writer)?;
        writeln!(writer, "### Definition")?;
        writeln!(writer)?;

        if struct_ty.fields.iter().all(|field| field.doc.is_empty()) {
            writeln!(writer, "| Name | Type |")?;
            writeln!(writer, "| ---- | ---- |")?;

            for field in &struct_ty.fields {
                let ty = compile_ty(&field.term);
                writeln!(writer, "| {} | {} |", field.name, ty)?;
            }
        } else {
            writeln!(writer, "| Name | Type | Description |")?;
            writeln!(writer, "| ---- | ---- | ------------|")?;

            for field in &struct_ty.fields {
                let desc = compile_field_description(&field.doc);
                let ty = compile_ty(&field.term);
                writeln!(writer, "| {} | {} | {} |", field.name, ty, desc)?;
            }

            // TODO: output long-form field docs
        }
    }

    Ok(())
}

fn compile_field_description(doc_lines: &[String]) -> String {
    let mut lines = doc_lines.iter();
    match lines.next().map(|l| l.trim().trim_end_matches('.')) {
        None => "".to_owned(),
        Some(first_line) => match lines.next() {
            None => first_line.to_owned(),
            // TODO: link ellipsis to long-form field docs
            Some(_) => format!("{}...", first_line),
        },
    }
}

fn compile_ty(term: &core::Term) -> &str {
    match term {
        // TODO: Link to specific docs
        core::Term::Item(_, name) => &name.0,
        // TODO: Link to global docs
        core::Term::U8(_) => "U8",
        core::Term::U16Le(_) => "U16Le",
        core::Term::U16Be(_) => "U16Be",
        core::Term::U32Le(_) => "U32Le",
        core::Term::U32Be(_) => "U32Be",
        core::Term::U64Le(_) => "U64Le",
        core::Term::U64Be(_) => "U64Be",
        core::Term::S8(_) => "S8",
        core::Term::S16Le(_) => "S16Le",
        core::Term::S16Be(_) => "S16Be",
        core::Term::S32Le(_) => "S32Le",
        core::Term::S32Be(_) => "S32Be",
        core::Term::S64Le(_) => "S64Le",
        core::Term::S64Be(_) => "S64Be",
        core::Term::F32Le(_) => "F32Le",
        core::Term::F32Be(_) => "F32Be",
        core::Term::F64Le(_) => "F64Le",
        core::Term::F64Be(_) => "F64Be",
        core::Term::Error(_) => "**invalid data description**",
    }
}
