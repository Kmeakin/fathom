use codespan::FileId;
use codespan_reporting::diagnostic::Diagnostic;
use std::io;
use std::io::prelude::*;

use crate::core;

pub fn compile_module(
    writer: &mut impl Write,
    module: &core::Module,
    report: &mut dyn FnMut(Diagnostic),
) -> io::Result<()> {
    let context = ModuleContext {
        _file_id: module.file_id,
    };

    let pkg_name = env!("CARGO_PKG_NAME");
    let pkg_version = env!("CARGO_PKG_VERSION");

    writeln!(writer, "<!--")?;
    writeln!(
        writer,
        "  This file is automatically @generated by {} {}",
        pkg_name, pkg_version,
    )?;
    writeln!(writer, "  It is not intended for manual editing.")?;
    writeln!(writer, "-->")?;

    for item in &module.items {
        writeln!(writer)?;
        match item {
            core::Item::Alias(alias) => compile_alias(&context, writer, alias, report)?,
            core::Item::Struct(struct_ty) => {
                compile_struct_ty(&context, writer, struct_ty, report)?
            }
        }
    }

    Ok(())
}

struct ModuleContext {
    _file_id: FileId,
}

fn compile_alias(
    context: &ModuleContext,
    writer: &mut impl Write,
    alias: &core::Alias,
    report: &mut dyn FnMut(Diagnostic),
) -> io::Result<()> {
    writeln!(writer, "## {}", alias.name)?;

    if !alias.doc.is_empty() {
        writeln!(writer)?;
        writeln!(writer, "### Description")?;
        writeln!(writer)?;
        for doc_line in alias.doc.iter() {
            // TODO: Bump inner heading levels
            let doc_line = match doc_line {
                line if line.starts_with(" ") => &line[" ".len()..],
                line => &line[..],
            };
            writeln!(writer, "{}", doc_line)?;
        }
    }

    writeln!(writer)?;
    writeln!(writer, "### Definition")?;
    writeln!(writer)?;
    writeln!(writer, "```")?;
    writeln!(writer, "{}", compile_ty(context, &alias.term, report))?;
    writeln!(writer, "```")?;

    Ok(())
}

fn compile_struct_ty(
    context: &ModuleContext,
    writer: &mut impl Write,
    struct_ty: &core::StructType,
    report: &mut dyn FnMut(Diagnostic),
) -> io::Result<()> {
    writeln!(writer, "## {}", struct_ty.name)?;

    if !struct_ty.doc.is_empty() {
        writeln!(writer)?;
        writeln!(writer, "### Description")?;
        writeln!(writer)?;
        for doc_line in struct_ty.doc.iter() {
            // TODO: Bump inner heading levels
            let doc_line = match doc_line {
                line if line.starts_with(" ") => &line[" ".len()..],
                line => &line[..],
            };
            writeln!(writer, "{}", doc_line)?;
        }
    }

    if !struct_ty.fields.is_empty() {
        writeln!(writer)?;
        writeln!(writer, "### Definition")?;
        writeln!(writer)?;

        if struct_ty.fields.iter().all(|field| field.doc.is_empty()) {
            writeln!(writer, "| Name | Type |")?;
            writeln!(writer, "| ---- | ---- |")?;

            for field in &struct_ty.fields {
                let ty = compile_ty(context, &field.term, report);
                writeln!(writer, "| {} | {} |", field.name, ty)?;
            }
        } else {
            writeln!(writer, "| Name | Type | Description |")?;
            writeln!(writer, "| ---- | ---- | ------------|")?;

            for field in &struct_ty.fields {
                let desc = compile_field_description(&field.doc);
                let ty = compile_ty(context, &field.term, report);
                writeln!(writer, "| {} | {} | {} |", field.name, ty, desc)?;
            }

            // TODO: output long-form field docs
        }
    }

    Ok(())
}

fn compile_field_description(doc_lines: &[String]) -> String {
    let mut lines = doc_lines.iter();
    match lines.next().map(|l| l.trim().trim_end_matches('.')) {
        None => "".to_owned(),
        Some(first_line) => match lines.next() {
            None => first_line.to_owned(),
            // TODO: link ellipsis to long-form field docs
            Some(_) => format!("{}...", first_line),
        },
    }
}

fn compile_ty<'term>(
    context: &ModuleContext,
    term: &'term core::Term,
    report: &mut dyn FnMut(Diagnostic),
) -> &'term str {
    match term {
        // TODO: Link to specific docs
        core::Term::Item(_, name) => &name.0,
        core::Term::Ann(term, _) => compile_ty(context, term, report),
        // TODO: Link to global docs
        core::Term::Kind(_) => "Kind",
        core::Term::Type(_) => "Type",
        core::Term::U8Type(_) => "U8",
        core::Term::U16LeType(_) => "U16Le",
        core::Term::U16BeType(_) => "U16Be",
        core::Term::U32LeType(_) => "U32Le",
        core::Term::U32BeType(_) => "U32Be",
        core::Term::U64LeType(_) => "U64Le",
        core::Term::U64BeType(_) => "U64Be",
        core::Term::S8Type(_) => "S8",
        core::Term::S16LeType(_) => "S16Le",
        core::Term::S16BeType(_) => "S16Be",
        core::Term::S32LeType(_) => "S32Le",
        core::Term::S32BeType(_) => "S32Be",
        core::Term::S64LeType(_) => "S64Le",
        core::Term::S64BeType(_) => "S64Be",
        core::Term::F32LeType(_) => "F32Le",
        core::Term::F32BeType(_) => "F32Be",
        core::Term::F64LeType(_) => "F64Le",
        core::Term::F64BeType(_) => "F64Be",
        core::Term::BoolType(_) => "Bool", // NOTE: Invalid if in struct
        core::Term::IntType(_) => "Int",   // NOTE: Invalid if in struct
        core::Term::F32Type(_) => "F32",   // NOTE: Invalid if in struct
        core::Term::F64Type(_) => "F64",   // NOTE: Invalid if in struct
        core::Term::Error(_) => "**invalid data description**",
    }
}
