use std::io;
use std::io::prelude::*;

use crate::compile::rust::{Item, Module, StructType, TypeAlias};

pub fn emit_module(writer: &mut impl Write, module: &Module) -> io::Result<()> {
    let pkg_name = env!("CARGO_PKG_NAME");
    let pkg_version = env!("CARGO_PKG_VERSION");

    writeln!(
        writer,
        "// This file is automatically @generated by {} {}",
        pkg_name, pkg_version,
    )?;
    writeln!(writer, "// It is not intended for manual editing.")?;

    for item in &module.items {
        emit_item(writer, &item)?;
    }

    Ok(())
}

fn emit_item(writer: &mut impl Write, item: &Item) -> io::Result<()> {
    match item {
        Item::TypeAlias(ty_alias) => emit_ty_alias(writer, ty_alias),
        Item::Struct(struct_ty) => emit_struct_ty(writer, struct_ty),
    }
}

fn emit_ty_alias(writer: &mut impl Write, ty_alias: &TypeAlias) -> io::Result<()> {
    writeln!(writer)?;

    for doc_line in ty_alias.doc.iter() {
        writeln!(writer, "///{}", doc_line)?;
    }

    writeln!(writer, "pub type {} = {};", ty_alias.name, ty_alias.ty.0)?;

    Ok(())
}

fn emit_struct_ty(writer: &mut impl Write, struct_ty: &StructType) -> io::Result<()> {
    writeln!(writer)?;

    for doc_line in struct_ty.doc.iter() {
        writeln!(writer, "///{}", doc_line)?;
    }

    if struct_ty.fields.is_empty() {
        writeln!(writer, "pub struct {} {{}}", struct_ty.name)?;
    } else {
        writeln!(writer, "pub struct {} {{", struct_ty.name)?;
        for field in &struct_ty.fields {
            for doc_line in field.doc.iter() {
                writeln!(writer, "    ///{}", doc_line)?;
            }

            write!(writer, "    pub {}: {},", field.name, field.host_ty.0)?;
            writeln!(writer)?;
        }
        writeln!(writer, "}}")?;
    }
    writeln!(writer)?;

    // Binary impl

    writeln!(writer, "impl ddl_rt::Binary for {} {{", struct_ty.name,)?;
    writeln!(writer, "    type Host = {};", struct_ty.name)?;
    writeln!(writer, "}}")?;
    writeln!(writer)?;

    // ReadBinary impl

    writeln!(
        writer,
        "impl<'data> ddl_rt::ReadBinary<'data> for {} {{",
        struct_ty.name,
    )?;
    if struct_ty.fields.is_empty() {
        writeln!(
            writer,
            "    fn read(_: &mut ddl_rt::ReadCtxt<'data>) -> Result<{}, ddl_rt::ReadError> {{",
            struct_ty.name,
        )?;
        writeln!(writer, "        Ok({} {{}})", struct_ty.name)?;
        writeln!(writer, "    }}")?;
    } else {
        writeln!(
            writer,
            "    fn read(ctxt: &mut ddl_rt::ReadCtxt<'data>) -> Result<{}, ddl_rt::ReadError> {{",
            struct_ty.name,
        )?;
        for field in &struct_ty.fields {
            write!(
                writer,
                "        let {} = ctxt.read::<{}>()?;",
                field.name, field.format_ty.0,
            )?;
            writeln!(writer)?;
        }
        writeln!(writer)?;
        writeln!(writer, "        Ok({} {{", struct_ty.name)?;
        for field in &struct_ty.fields {
            writeln!(writer, "            {},", field.name)?;
        }
        writeln!(writer, "        }})")?;
        writeln!(writer, "    }}")?;
    }
    writeln!(writer, "}}")?;

    Ok(())
}
