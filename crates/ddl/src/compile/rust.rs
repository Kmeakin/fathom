use codespan::FileId;
use codespan_reporting::diagnostic::Diagnostic;
use num_bigint::BigInt;
use std::io;
use std::io::prelude::*;

use crate::core;

pub fn compile_module(
    writer: &mut impl Write,
    module: &core::Module,
    report: &mut dyn FnMut(Diagnostic),
) -> io::Result<()> {
    let context = ModuleContext {
        _file_id: module.file_id,
    };

    let pkg_name = env!("CARGO_PKG_NAME");
    let pkg_version = env!("CARGO_PKG_VERSION");

    writeln!(
        writer,
        "// This file is automatically @generated by {} {}",
        pkg_name, pkg_version,
    )?;
    writeln!(writer, "// It is not intended for manual editing.")?;

    for item in &module.items {
        writeln!(writer)?;
        match item {
            core::Item::Alias(alias) => compile_alias(&context, writer, alias, report)?,
            core::Item::Struct(struct_ty) => {
                compile_struct_ty(&context, writer, struct_ty, report)?
            }
        }
    }

    Ok(())
}

struct ModuleContext {
    _file_id: FileId,
}

fn compile_alias(
    context: &ModuleContext,
    writer: &mut impl Write,
    alias: &core::Alias,
    report: &mut dyn FnMut(Diagnostic),
) -> io::Result<()> {
    for doc_line in alias.doc.iter() {
        writeln!(writer, "///{}", doc_line)?;
    }

    let ty = compile_ty(context, &alias.term, report);
    writeln!(writer, "pub type {} = {};", alias.name, ty)?;

    Ok(())
}

fn compile_struct_ty(
    context: &ModuleContext,
    writer: &mut impl Write,
    struct_ty: &core::StructType,
    report: &mut dyn FnMut(Diagnostic),
) -> io::Result<()> {
    // Struct definition

    for doc_line in struct_ty.doc.iter() {
        writeln!(writer, "///{}", doc_line)?;
    }

    if struct_ty.fields.is_empty() {
        writeln!(writer, "pub struct {} {{}}", struct_ty.name)?;
    } else {
        writeln!(writer, "pub struct {} {{", struct_ty.name)?;
        for field in &struct_ty.fields {
            for doc_line in field.doc.iter() {
                writeln!(writer, "    ///{}", doc_line)?;
            }

            let ty = compile_host_ty(context, &field.term, report);
            write!(writer, "    pub {}: {},", field.name, ty,)?;
            writeln!(writer)?;
        }
        writeln!(writer, "}}")?;
    }
    writeln!(writer)?;

    // Binary impl

    writeln!(writer, "impl ddl_rt::Binary for {} {{", struct_ty.name,)?;
    writeln!(writer, "    type Host = {};", struct_ty.name)?;
    writeln!(writer, "}}")?;
    writeln!(writer)?;

    // ReadBinary impl

    writeln!(
        writer,
        "impl<'data> ddl_rt::ReadBinary<'data> for {} {{",
        struct_ty.name,
    )?;
    if struct_ty.fields.is_empty() {
        writeln!(
            writer,
            "    fn read(_: &mut ddl_rt::ReadCtxt<'data>) -> Result<{}, ddl_rt::ReadError> {{",
            struct_ty.name,
        )?;
        writeln!(writer, "        Ok({} {{}})", struct_ty.name)?;
        writeln!(writer, "    }}")?;
    } else {
        writeln!(
            writer,
            "    fn read(ctxt: &mut ddl_rt::ReadCtxt<'data>) -> Result<{}, ddl_rt::ReadError> {{",
            struct_ty.name,
        )?;
        for field in &struct_ty.fields {
            write!(
                writer,
                "        let {} = ctxt.read::<{}>()?;",
                field.name,
                compile_ty(context, &field.term, report),
            )?;
            writeln!(writer)?;
        }
        writeln!(writer)?;
        writeln!(writer, "        Ok({} {{", struct_ty.name)?;
        for field in &struct_ty.fields {
            writeln!(writer, "            {},", field.name)?;
        }
        writeln!(writer, "        }})")?;
        writeln!(writer, "    }}")?;
    }
    writeln!(writer, "}}")?;

    Ok(())
}

fn compile_ty<'term>(
    context: &ModuleContext,
    term: &'term core::Term,
    report: &mut dyn FnMut(Diagnostic),
) -> &'term str {
    match term {
        core::Term::Item(_, label) => &label.0, // TODO: check if in scope, warn if not
        core::Term::Ann(term, _) => compile_ty(context, term, report),
        core::Term::U8(_) => "ddl_rt::U8",
        core::Term::U16Le(_) => "ddl_rt::U16Le",
        core::Term::U16Be(_) => "ddl_rt::U16Be",
        core::Term::U32Le(_) => "ddl_rt::U32Le",
        core::Term::U32Be(_) => "ddl_rt::U32Be",
        core::Term::U64Le(_) => "ddl_rt::U64Le",
        core::Term::U64Be(_) => "ddl_rt::U64Be",
        core::Term::S8(_) => "ddl_rt::I8",
        core::Term::S16Le(_) => "ddl_rt::I16Le",
        core::Term::S16Be(_) => "ddl_rt::I16Be",
        core::Term::S32Le(_) => "ddl_rt::I32Le",
        core::Term::S32Be(_) => "ddl_rt::I32Be",
        core::Term::S64Le(_) => "ddl_rt::I64Le",
        core::Term::S64Be(_) => "ddl_rt::I64Be",
        core::Term::F32Le(_) => "ddl_rt::F32Le",
        core::Term::F32Be(_) => "ddl_rt::F32Be",
        core::Term::F64Le(_) => "ddl_rt::F64Le",
        core::Term::F64Be(_) => "ddl_rt::F64Be",
        core::Term::Kind(_) | core::Term::Type(_) => "ddl_rt::InvalidDataDescription", // TODO: skip
        core::Term::Error(_) => "ddl_rt::InvalidDataDescription",
    }
}

fn compile_host_ty<'term>(
    context: &ModuleContext,
    term: &'term core::Term,
    report: &mut dyn FnMut(Diagnostic),
) -> &'term str {
    match term {
        core::Term::Item(_, label) => &label.0, // TODO: check if in scope, warn if not
        core::Term::Ann(term, _) => compile_host_ty(context, term, report),
        core::Term::U8(_) => "u8",
        core::Term::U16Le(_) => "u16",
        core::Term::U16Be(_) => "u16",
        core::Term::U32Le(_) => "u32",
        core::Term::U32Be(_) => "u32",
        core::Term::U64Le(_) => "u64",
        core::Term::U64Be(_) => "u64",
        core::Term::S8(_) => "i8",
        core::Term::S16Le(_) => "i16",
        core::Term::S16Be(_) => "i16",
        core::Term::S32Le(_) => "i32",
        core::Term::S32Be(_) => "i32",
        core::Term::S64Le(_) => "i64",
        core::Term::S64Be(_) => "i64",
        core::Term::F32Le(_) => "f32",
        core::Term::F32Be(_) => "f32",
        core::Term::F64Le(_) => "f64",
        core::Term::F64Be(_) => "f64",
        core::Term::Kind(_) | core::Term::Type(_) => "ddl_rt::InvalidDataDescription", // TODO: skip
        core::Term::Error(_) => "ddl_rt::InvalidDataDescription",
    }
}

#[allow(dead_code)]
fn host_int(min: &BigInt, max: &BigInt) -> Option<&'static str> {
    use std::{i16, i32, i64, i8, u16, u32, u64, u8};

    match () {
        () if *min >= u8::MIN.into() && *max <= u8::MAX.into() => Some("u8"),
        () if *min >= u16::MIN.into() && *max <= u16::MAX.into() => Some("u16"),
        () if *min >= u32::MIN.into() && *max <= u32::MAX.into() => Some("u32"),
        () if *min >= u64::MIN.into() && *max <= u64::MAX.into() => Some("u64"),
        () if *min >= i8::MIN.into() && *max <= i8::MAX.into() => Some("i8"),
        () if *min >= i16::MIN.into() && *max <= i16::MAX.into() => Some("i16"),
        () if *min >= i32::MIN.into() && *max <= i32::MAX.into() => Some("i32"),
        () if *min >= i64::MIN.into() && *max <= i64::MAX.into() => Some("i64"),
        () if min > max => None, // Impossible range
        _ => None,               // TODO: use bigint if outside bounds
    }
}
