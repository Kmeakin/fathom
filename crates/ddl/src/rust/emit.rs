use std::io;
use std::io::prelude::*;

use crate::rust::{
    Alias, Const, Constant, Function, Item, Module, Pattern, StructType, Term, Type,
};

// TODO: Make this path configurable
const RT_NAME: &str = "ddl_rt";

pub fn emit_module(writer: &mut impl Write, module: &Module) -> io::Result<()> {
    let pkg_name = env!("CARGO_PKG_NAME");
    let pkg_version = env!("CARGO_PKG_VERSION");

    writeln!(
        writer,
        "// This file is automatically @generated by {} {}",
        pkg_name, pkg_version,
    )?;
    writeln!(writer, "// It is not intended for manual editing.")?;

    if !module.doc.is_empty() {
        writeln!(writer)?;
        for doc_line in module.doc.iter() {
            writeln!(writer, "//!{}", doc_line)?;
        }
    }

    for item in &module.items {
        emit_item(writer, &item)?;
    }

    Ok(())
}

fn emit_item(writer: &mut impl Write, item: &Item) -> io::Result<()> {
    match item {
        Item::Const(const_) => emit_const(writer, const_),
        Item::Function(function) => emit_function(writer, function),
        Item::Alias(ty_alias) => emit_alias(writer, ty_alias),
        Item::Struct(struct_ty) => emit_struct_ty(writer, struct_ty),
    }
}

fn emit_const(writer: &mut impl Write, const_: &Const) -> io::Result<()> {
    writeln!(writer)?;

    for doc_line in const_.doc.iter() {
        writeln!(writer, "///{}", doc_line)?;
    }

    write!(writer, "pub const {}: ", const_.name)?;
    emit_ty(writer, &const_.ty)?;
    write!(writer, " = ")?;
    emit_term(writer, &const_.term)?;
    writeln!(writer, ";")?;

    Ok(())
}

fn emit_function(writer: &mut impl Write, function: &Function) -> io::Result<()> {
    writeln!(writer)?;

    for doc_line in function.doc.iter() {
        writeln!(writer, "///{}", doc_line)?;
    }

    write!(writer, "pub ")?;
    if function.is_const {
        write!(writer, "const ")?;
    }
    write!(writer, "fn {}() -> ", function.name)?;
    emit_ty(writer, &function.ty)?;
    writeln!(writer, " {{")?;
    write!(writer, "    ")?;
    emit_term(writer, &function.term)?;
    writeln!(writer)?;
    writeln!(writer, "}}")?;

    Ok(())
}

fn emit_alias(writer: &mut impl Write, ty_alias: &Alias) -> io::Result<()> {
    writeln!(writer)?;

    for doc_line in ty_alias.doc.iter() {
        writeln!(writer, "///{}", doc_line)?;
    }

    write!(writer, "pub type {} = ", ty_alias.name)?;
    emit_ty(writer, &ty_alias.ty)?;
    writeln!(writer, ";")?;

    Ok(())
}

fn emit_struct_ty(writer: &mut impl Write, struct_ty: &StructType) -> io::Result<()> {
    use itertools::Itertools;

    writeln!(writer)?;

    for doc_line in struct_ty.doc.iter() {
        writeln!(writer, "///{}", doc_line)?;
    }

    if !struct_ty.derives.is_empty() {
        writeln!(
            writer,
            "#[derive({})]",
            struct_ty.derives.iter().format(", "),
        )?;
    }
    if struct_ty.fields.is_empty() {
        writeln!(writer, "pub struct {} {{}}", struct_ty.name)?;
    } else {
        writeln!(writer, "pub struct {} {{", struct_ty.name)?;
        for field in &struct_ty.fields {
            write!(writer, "    {}: ", field.name)?;
            emit_ty(writer, &field.host_ty)?;
            write!(writer, ",")?;
            writeln!(writer)?;
        }
        writeln!(writer, "}}")?;
    }
    writeln!(writer)?;

    // Field accessors

    if !struct_ty.fields.is_empty() {
        writeln!(writer, "impl {} {{", struct_ty.name,)?;
        for (i, field) in struct_ty.fields.iter().enumerate() {
            let sigil = match field.by_ref {
                true => "&",
                false => "",
            };

            if i != 0 {
                writeln!(writer)?;
            }

            for doc_line in field.doc.iter() {
                writeln!(writer, "    ///{}", doc_line)?;
            }
            write!(writer, "    pub fn {}(&self) -> {}", field.name, sigil)?;
            emit_ty(writer, &field.host_ty)?;
            writeln!(writer, " {{")?;
            writeln!(writer, "        {}self.{}", sigil, field.name)?;
            writeln!(writer, "    }}")?;
        }
        writeln!(writer, "}}")?;
        writeln!(writer)?;
    }

    // Format impl

    writeln!(
        writer,
        "impl {rt}::Format for {struct_ty} {{",
        rt = RT_NAME,
        struct_ty = struct_ty.name,
    )?;
    writeln!(writer, "    type Host = {};", struct_ty.name)?;
    writeln!(writer, "}}")?;
    writeln!(writer)?;

    // ReadFormat impl

    writeln!(
        writer,
        "impl<'data> {rt}::ReadFormat<'data> for {struct_ty} {{",
        rt = RT_NAME,
        struct_ty = struct_ty.name,
    )?;
    if struct_ty.fields.is_empty() {
        writeln!(
            writer,
            "    fn read(_: &mut {rt}::FormatReader<'data>) -> Result<{struct_ty}, {rt}::ReadError> {{",
            rt = RT_NAME,
            struct_ty = struct_ty.name,
        )?;
        writeln!(writer, "        Ok({} {{}})", struct_ty.name)?;
        writeln!(writer, "    }}")?;
    } else {
        writeln!(
            writer,
            "    fn read(reader: &mut {rt}::FormatReader<'data>) -> Result<{struct_ty}, {rt}::ReadError> {{",
            rt = RT_NAME,
            struct_ty = struct_ty.name,
        )?;
        for field in &struct_ty.fields {
            write!(writer, "        let {} = ", field.name)?;
            emit_ty_read(writer, &field.format_ty)?;
            write!(writer, ";")?;
            writeln!(writer)?;
        }
        writeln!(writer)?;
        writeln!(writer, "        Ok({} {{", struct_ty.name)?;
        for field in &struct_ty.fields {
            writeln!(writer, "            {},", field.name)?;
        }
        writeln!(writer, "        }})")?;
        writeln!(writer, "    }}")?;
    }
    writeln!(writer, "}}")?;

    Ok(())
}

fn emit_ty(writer: &mut impl Write, ty: &Type) -> io::Result<()> {
    match ty {
        Type::Name(name, arguments) => {
            write!(writer, "{}", name)?;
            if !arguments.is_empty() {
                write!(writer, "<")?;
                for (i, argument) in arguments.iter().enumerate() {
                    if i != 0 {
                        write!(writer, ", ")?;
                    }
                    emit_ty(writer, argument)?;
                }
                write!(writer, ">")?;
            }
            Ok(())
        }
        Type::If(_, _, _) => write!(writer, "{rt}::InvalidDataDescription", rt = RT_NAME),
    }
}

fn emit_ty_read(writer: &mut impl Write, ty: &Type) -> io::Result<()> {
    match ty {
        Type::Name(name, arguments) => {
            write!(writer, "reader.read::<{}", name)?;
            if !arguments.is_empty() {
                write!(writer, "<")?;
                for (i, argument) in arguments.iter().enumerate() {
                    if i != 0 {
                        write!(writer, ", ")?;
                    }
                    emit_ty(writer, argument)?;
                }
                write!(writer, ">")?;
            }
            write!(writer, ">()?")
        }
        Type::If(cond, lhs, rhs) => {
            write!(writer, "if ")?;
            emit_term(writer, cond)?;
            write!(writer, " {{ {rt}::Either::Left(", rt = RT_NAME)?;
            emit_ty_read(writer, lhs)?;
            write!(writer, ") }} else {{ {rt}::Either::Right(", rt = RT_NAME)?;
            emit_ty_read(writer, rhs)?;
            write!(writer, ") }}")
        }
    }
}

fn emit_constant(writer: &mut impl Write, constant: &Constant) -> io::Result<()> {
    match constant {
        Constant::U8(value) => write!(writer, "{}u8", value),
        Constant::U16(value) => write!(writer, "{}u16", value),
        Constant::U32(value) => write!(writer, "{}u32", value),
        Constant::U64(value) => write!(writer, "{}u64", value),
        Constant::I8(value) => write!(writer, "{}i8", value),
        Constant::I16(value) => write!(writer, "{}i16", value),
        Constant::I32(value) => write!(writer, "{}i32", value),
        Constant::I64(value) => write!(writer, "{}i64", value),
        Constant::F32(value) => write!(writer, "{}f32", value),
        Constant::F64(value) => write!(writer, "{}f64", value),
    }
}

fn emit_term(writer: &mut impl Write, term: &Term) -> io::Result<()> {
    match term {
        Term::Name(name) => write!(writer, "{}", name),
        Term::Panic(message) => write!(writer, "panic!({:?})", message),
        Term::Constant(constant) => emit_constant(writer, constant),
        Term::Call(term) => {
            emit_term(writer, term)?;
            write!(writer, "()")
        }
        Term::If(head, if_true, if_false) => {
            write!(writer, "if ")?;
            emit_term(writer, head)?;
            write!(writer, " {{ ")?;
            emit_term(writer, if_true)?;
            write!(writer, " }} else {{ ")?;
            emit_term(writer, if_false)?;
            write!(writer, " }}")
        }
        Term::Match(head, branches) => {
            write!(writer, "match ")?;
            emit_term(writer, head)?;
            write!(writer, " {{ ")?;
            for (i, (pattern, term)) in branches.iter().enumerate() {
                if i != 0 {
                    write!(writer, ", ")?;
                }
                emit_pattern(writer, pattern)?;
                write!(writer, " => ")?;
                emit_term(writer, term)?;
            }
            write!(writer, " }}")
        }
    }
}

fn emit_pattern(writer: &mut impl Write, pattern: &Pattern) -> io::Result<()> {
    match pattern {
        Pattern::Name(name) => write!(writer, "{}", name),
        Pattern::Constant(constant) => emit_constant(writer, constant),
    }
}
