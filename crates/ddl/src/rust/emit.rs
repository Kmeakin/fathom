use std::io;
use std::io::prelude::*;

use crate::rust::{
    Alias, Block, Const, Constant, EnumType, Function, Item, Module, Pattern, Statement,
    StructType, Term, Type,
};

// TODO: Make this path configurable
const RT_NAME: &str = "ddl_rt";

pub fn emit_module(writer: &mut impl Write, module: &Module) -> io::Result<()> {
    let pkg_name = env!("CARGO_PKG_NAME");
    let pkg_version = env!("CARGO_PKG_VERSION");

    writeln!(
        writer,
        "// This file is automatically @generated by {} {}",
        pkg_name, pkg_version,
    )?;
    writeln!(writer, "// It is not intended for manual editing.")?;

    if !module.doc.is_empty() {
        writeln!(writer)?;
        for doc_line in module.doc.iter() {
            writeln!(writer, "//!{}", doc_line)?;
        }
    }

    for item in &module.items {
        emit_item(writer, &item)?;
    }

    Ok(())
}

fn emit_item(writer: &mut impl Write, item: &Item) -> io::Result<()> {
    match item {
        Item::Const(const_) => emit_const(writer, const_),
        Item::Function(function) => emit_function(writer, function),
        Item::Alias(ty_alias) => emit_alias(writer, ty_alias),
        Item::Struct(struct_ty) => emit_struct_ty(writer, struct_ty),
        Item::Enum(enum_ty) => emit_enum_ty(writer, enum_ty),
    }
}

fn emit_const(writer: &mut impl Write, const_: &Const) -> io::Result<()> {
    writeln!(writer)?;

    for doc_line in const_.doc.iter() {
        writeln!(writer, "///{}", doc_line)?;
    }

    write!(writer, "pub const {}: ", const_.name)?;
    emit_ty(writer, &const_.ty)?;
    write!(writer, " = ")?;
    emit_term(writer, &const_.term)?;
    writeln!(writer, ";")?;

    Ok(())
}

fn emit_function(writer: &mut impl Write, function: &Function) -> io::Result<()> {
    writeln!(writer)?;

    for doc_line in function.doc.iter() {
        writeln!(writer, "///{}", doc_line)?;
    }

    write!(writer, "pub ")?;
    if function.is_const {
        write!(writer, "const ")?;
    }
    write!(writer, "fn {}() -> ", function.name)?;
    emit_ty(writer, &function.ty)?;
    writeln!(writer, " {{")?;
    emit_block(writer, &function.block)?;
    writeln!(writer, "}}")?;

    Ok(())
}

fn emit_alias(writer: &mut impl Write, ty_alias: &Alias) -> io::Result<()> {
    writeln!(writer)?;

    for doc_line in ty_alias.doc.iter() {
        writeln!(writer, "///{}", doc_line)?;
    }

    write!(writer, "pub type {} = ", ty_alias.name)?;
    emit_ty(writer, &ty_alias.ty)?;
    writeln!(writer, ";")?;

    Ok(())
}

fn emit_struct_ty(writer: &mut impl Write, struct_ty: &StructType) -> io::Result<()> {
    use itertools::Itertools;

    writeln!(writer)?;

    for doc_line in struct_ty.doc.iter() {
        writeln!(writer, "///{}", doc_line)?;
    }

    if !struct_ty.derives.is_empty() {
        writeln!(
            writer,
            "#[derive({})]",
            struct_ty.derives.iter().format(", "),
        )?;
    }
    if struct_ty.fields.is_empty() {
        writeln!(writer, "pub struct {} {{}}", struct_ty.name)?;
    } else {
        writeln!(writer, "pub struct {} {{", struct_ty.name)?;
        for field in &struct_ty.fields {
            write!(writer, "    {}: ", field.name)?;
            emit_ty(writer, &field.ty)?;
            write!(writer, ",")?;
            writeln!(writer)?;
        }
        writeln!(writer, "}}")?;
    }
    writeln!(writer)?;

    // Field accessors

    if !struct_ty.fields.is_empty() {
        writeln!(writer, "impl {} {{", struct_ty.name,)?;
        for (i, field) in struct_ty.fields.iter().enumerate() {
            let sigil = match field.by_ref {
                true => "&",
                false => "",
            };

            if i != 0 {
                writeln!(writer)?;
            }

            for doc_line in field.doc.iter() {
                writeln!(writer, "    ///{}", doc_line)?;
            }
            write!(writer, "    pub fn {}(&self) -> {}", field.name, sigil)?;
            emit_ty(writer, &field.ty)?;
            writeln!(writer, " {{")?;
            writeln!(writer, "        {}self.{}", sigil, field.name)?;
            writeln!(writer, "    }}")?;
        }
        writeln!(writer, "}}")?;
        writeln!(writer)?;
    }

    // Format impl

    writeln!(
        writer,
        "impl {rt}::Format for {struct_ty} {{",
        rt = RT_NAME,
        struct_ty = struct_ty.name,
    )?;
    writeln!(writer, "    type Host = {};", struct_ty.name)?;
    writeln!(writer, "}}")?;
    writeln!(writer)?;

    // ReadFormat impl

    if let Some(read) = &struct_ty.read {
        writeln!(
            writer,
            "impl<'data> {rt}::ReadFormat<'data> for {struct_ty} {{",
            rt = RT_NAME,
            struct_ty = struct_ty.name,
        )?;
        writeln!(
            writer,
            "    fn read({reader}: &mut {rt}::FormatReader<'data>) -> Result<{struct_ty}, {rt}::ReadError> {{",
            rt = RT_NAME,
            reader = if struct_ty.fields.is_empty() { "_" } else { "reader" },
            struct_ty = struct_ty.name,
        )?;
        emit_block(writer, read)?;
        writeln!(writer, "    }}")?;
        writeln!(writer, "}}")?;
    }

    Ok(())
}

fn emit_enum_ty(writer: &mut impl Write, enum_ty: &EnumType) -> io::Result<()> {
    use itertools::Itertools;

    writeln!(writer)?;

    for doc_line in enum_ty.doc.iter() {
        writeln!(writer, "///{}", doc_line)?;
    }

    if !enum_ty.derives.is_empty() {
        writeln!(writer, "#[derive({})]", enum_ty.derives.iter().format(", "))?;
    }
    if enum_ty.variants.is_empty() {
        writeln!(writer, "pub enum {} {{}}", enum_ty.name)?;
    } else {
        writeln!(writer, "pub enum {} {{", enum_ty.name)?;
        for variant in &enum_ty.variants {
            write!(writer, "    {}(", variant.name)?;
            emit_ty(writer, &variant.ty)?;
            write!(writer, "),")?;
            writeln!(writer)?;
        }
        writeln!(writer, "}}")?;
    }

    Ok(())
}

fn emit_ty_arguments(writer: &mut impl Write, arguments: &[Type]) -> io::Result<()> {
    if !arguments.is_empty() {
        write!(writer, "<")?;
        for (i, argument) in arguments.iter().enumerate() {
            if i != 0 {
                write!(writer, ", ")?;
            }
            emit_ty(writer, argument)?;
        }
        write!(writer, ">")?;
    }
    Ok(())
}

fn emit_ty(writer: &mut impl Write, ty: &Type) -> io::Result<()> {
    match ty {
        Type::Name(name, arguments) => {
            write!(writer, "{}", name)?;
            emit_ty_arguments(writer, arguments)
        }
    }
}

fn emit_block(writer: &mut impl Write, block: &Block) -> io::Result<()> {
    for statement in &block.statements {
        emit_statement(writer, statement)?;
        writeln!(writer, ";")?;
    }
    if let Some(term) = &block.term {
        if !block.statements.is_empty() {
            writeln!(writer, "")?;
        }
        write!(writer, "        ")?;
        emit_term(writer, term)?;
        writeln!(writer)?;
    }
    Ok(())
}

fn emit_statement(writer: &mut impl Write, statement: &Statement) -> io::Result<()> {
    match statement {
        Statement::Let(name, term) => {
            write!(writer, "        let {} = ", name)?;
            emit_term(writer, term)?;
        }
        Statement::Term(term) => {
            write!(writer, "        ")?;
            emit_term(writer, term)?;
        }
    }

    Ok(())
}

fn emit_constant(writer: &mut impl Write, constant: &Constant) -> io::Result<()> {
    match constant {
        Constant::U8(value) => write!(writer, "{}u8", value),
        Constant::U16(value) => write!(writer, "{}u16", value),
        Constant::U32(value) => write!(writer, "{}u32", value),
        Constant::U64(value) => write!(writer, "{}u64", value),
        Constant::I8(value) => write!(writer, "{}i8", value),
        Constant::I16(value) => write!(writer, "{}i16", value),
        Constant::I32(value) => write!(writer, "{}i32", value),
        Constant::I64(value) => write!(writer, "{}i64", value),
        Constant::F32(value) => write!(writer, "{}f32", value),
        Constant::F64(value) => write!(writer, "{}f64", value),
    }
}

fn emit_term(writer: &mut impl Write, term: &Term) -> io::Result<()> {
    match term {
        Term::Name(name) => write!(writer, "{}", name),
        Term::Panic(message) => write!(writer, "panic!({:?})", message),
        Term::Constant(constant) => emit_constant(writer, constant),
        Term::Call(term, arguments) => {
            emit_term(writer, term)?;
            write!(writer, "(")?;
            for (i, argument) in arguments.iter().enumerate() {
                if i != 0 {
                    write!(writer, ", ")?;
                }
                emit_term(writer, argument)?;
            }
            write!(writer, ")")
        }
        Term::If(head, if_true, if_false) => {
            write!(writer, "if ")?;
            emit_term(writer, head)?;
            write!(writer, " {{ ")?;
            emit_term(writer, if_true)?;
            write!(writer, " }} else {{ ")?;
            emit_term(writer, if_false)?;
            write!(writer, " }}")
        }
        Term::Match(head, branches) => {
            write!(writer, "match ")?;
            emit_term(writer, head)?;
            write!(writer, " {{ ")?;
            for (i, (pattern, term)) in branches.iter().enumerate() {
                if i != 0 {
                    write!(writer, ", ")?;
                }
                emit_pattern(writer, pattern)?;
                write!(writer, " => ")?;
                emit_term(writer, term)?;
            }
            write!(writer, " }}")
        }
        Term::Read(ty) => {
            write!(writer, "reader.read::<")?;
            emit_ty(writer, ty)?;
            write!(writer, ">()?")
        }
        Term::Struct(name, fields) if fields.is_empty() => write!(writer, "{} {{}}", name),
        Term::Struct(name, fields) => {
            writeln!(writer, "{} {{", name)?;
            for (name, term) in fields {
                write!(writer, "            ")?;
                match term {
                    Some(term) => {
                        write!(writer, "{} : ", name)?;
                        emit_term(writer, term)?;
                        writeln!(writer, ",")?;
                    }
                    None => writeln!(writer, "{},", name)?,
                }
            }
            write!(writer, "        }}")
        }
    }
}

fn emit_pattern(writer: &mut impl Write, pattern: &Pattern) -> io::Result<()> {
    match pattern {
        Pattern::Name(name) => write!(writer, "{}", name),
        Pattern::Constant(constant) => emit_constant(writer, constant),
    }
}
