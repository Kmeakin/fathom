use std::io;
use std::io::prelude::*;

use crate::rust::{Alias, Const, Function, Item, Module, RtType, StructType, Term, Type};

// TODO: Make this path configurable
const RT_NAME: &str = "ddl_rt";

pub fn emit_module(writer: &mut impl Write, module: &Module) -> io::Result<()> {
    let pkg_name = env!("CARGO_PKG_NAME");
    let pkg_version = env!("CARGO_PKG_VERSION");

    writeln!(
        writer,
        "// This file is automatically @generated by {} {}",
        pkg_name, pkg_version,
    )?;
    writeln!(writer, "// It is not intended for manual editing.")?;

    if !module.doc.is_empty() {
        writeln!(writer)?;
        for doc_line in module.doc.iter() {
            writeln!(writer, "//!{}", doc_line)?;
        }
    }

    for item in &module.items {
        emit_item(writer, &item)?;
    }

    Ok(())
}

fn emit_item(writer: &mut impl Write, item: &Item) -> io::Result<()> {
    match item {
        Item::Const(const_) => emit_const(writer, const_),
        Item::Function(function) => emit_function(writer, function),
        Item::Alias(ty_alias) => emit_alias(writer, ty_alias),
        Item::Struct(struct_ty) => emit_struct_ty(writer, struct_ty),
    }
}

fn emit_const(writer: &mut impl Write, const_: &Const) -> io::Result<()> {
    writeln!(writer)?;

    for doc_line in const_.doc.iter() {
        writeln!(writer, "///{}", doc_line)?;
    }

    write!(writer, "pub const {}: ", const_.name)?;
    emit_ty(writer, &const_.ty)?;
    write!(writer, " = ")?;
    emit_term(writer, &const_.term)?;
    writeln!(writer, ";")?;

    Ok(())
}

fn emit_function(writer: &mut impl Write, function: &Function) -> io::Result<()> {
    writeln!(writer)?;

    for doc_line in function.doc.iter() {
        writeln!(writer, "///{}", doc_line)?;
    }

    write!(writer, "pub ")?;
    if function.is_const {
        write!(writer, "const ")?;
    }
    write!(writer, "fn {}() -> ", function.name)?;
    emit_ty(writer, &function.ty)?;
    writeln!(writer, " {{")?;
    write!(writer, "    ")?;
    emit_term(writer, &function.term)?;
    writeln!(writer)?;
    writeln!(writer, "}}")?;

    Ok(())
}

fn emit_alias(writer: &mut impl Write, ty_alias: &Alias) -> io::Result<()> {
    writeln!(writer)?;

    for doc_line in ty_alias.doc.iter() {
        writeln!(writer, "///{}", doc_line)?;
    }

    write!(writer, "pub type {} = ", ty_alias.name)?;
    emit_ty(writer, &ty_alias.ty)?;
    writeln!(writer, ";")?;

    Ok(())
}

fn emit_struct_ty(writer: &mut impl Write, struct_ty: &StructType) -> io::Result<()> {
    use itertools::Itertools;

    writeln!(writer)?;

    for doc_line in struct_ty.doc.iter() {
        writeln!(writer, "///{}", doc_line)?;
    }

    if !struct_ty.derives.is_empty() {
        writeln!(
            writer,
            "#[derive({})]",
            struct_ty.derives.iter().format(", "),
        )?;
    }
    if struct_ty.fields.is_empty() {
        writeln!(writer, "pub struct {} {{}}", struct_ty.name)?;
    } else {
        writeln!(writer, "pub struct {} {{", struct_ty.name)?;
        for field in &struct_ty.fields {
            write!(writer, "    {}: ", field.name)?;
            emit_ty(writer, &field.host_ty)?;
            write!(writer, ",")?;
            writeln!(writer)?;
        }
        writeln!(writer, "}}")?;
    }
    writeln!(writer)?;

    // Field accessors

    if !struct_ty.fields.is_empty() {
        writeln!(writer, "impl {} {{", struct_ty.name,)?;
        for (i, field) in struct_ty.fields.iter().enumerate() {
            let sigil = match field.by_ref {
                true => "&",
                false => "",
            };

            if i != 0 {
                writeln!(writer)?;
            }

            for doc_line in field.doc.iter() {
                writeln!(writer, "    ///{}", doc_line)?;
            }
            write!(writer, "    pub fn {}(&self) -> {}", field.name, sigil)?;
            emit_ty(writer, &field.host_ty)?;
            writeln!(writer, " {{")?;
            writeln!(writer, "        {}self.{}", sigil, field.name)?;
            writeln!(writer, "    }}")?;
        }
        writeln!(writer, "}}")?;
        writeln!(writer)?;
    }

    // Format impl

    writeln!(
        writer,
        "impl {rt}::Format for {struct_ty} {{",
        rt = RT_NAME,
        struct_ty = struct_ty.name,
    )?;
    writeln!(writer, "    type Host = {};", struct_ty.name)?;
    writeln!(writer, "}}")?;
    writeln!(writer)?;

    // ReadFormat impl

    writeln!(
        writer,
        "impl<'data> {rt}::ReadFormat<'data> for {struct_ty} {{",
        rt = RT_NAME,
        struct_ty = struct_ty.name,
    )?;
    if struct_ty.fields.is_empty() {
        writeln!(
            writer,
            "    fn read(_: &mut {rt}::FormatReader<'data>) -> Result<{struct_ty}, {rt}::ReadError> {{",
            rt = RT_NAME,
            struct_ty = struct_ty.name,
        )?;
        writeln!(writer, "        Ok({} {{}})", struct_ty.name)?;
        writeln!(writer, "    }}")?;
    } else {
        writeln!(
            writer,
            "    fn read(reader: &mut {rt}::FormatReader<'data>) -> Result<{struct_ty}, {rt}::ReadError> {{",
            rt = RT_NAME,
            struct_ty = struct_ty.name,
        )?;
        for field in &struct_ty.fields {
            write!(writer, "        let {} = ", field.name)?;
            emit_ty_read(writer, &field.format_ty)?;
            write!(writer, ";")?;
            writeln!(writer)?;
        }
        writeln!(writer)?;
        writeln!(writer, "        Ok({} {{", struct_ty.name)?;
        for field in &struct_ty.fields {
            writeln!(writer, "            {},", field.name)?;
        }
        writeln!(writer, "        }})")?;
        writeln!(writer, "    }}")?;
    }
    writeln!(writer, "}}")?;

    Ok(())
}

fn emit_ty(writer: &mut impl Write, ty: &Type) -> io::Result<()> {
    match ty {
        Type::Var(name) => write!(writer, "{}", name),
        Type::If(_, _, _) => write!(writer, "{rt}::InvalidDataDescription", rt = RT_NAME),
        Type::U8 => write!(writer, "u8"),
        Type::U16 => write!(writer, "u16"),
        Type::U32 => write!(writer, "u32"),
        Type::U64 => write!(writer, "u64"),
        Type::I8 => write!(writer, "i8"),
        Type::I16 => write!(writer, "i16"),
        Type::I32 => write!(writer, "i32"),
        Type::I64 => write!(writer, "i64"),
        Type::F32 => write!(writer, "f32"),
        Type::F64 => write!(writer, "f64"),
        Type::Bool => write!(writer, "bool"),
        Type::Rt(rt_ty) => match rt_ty {
            RtType::Either(lhs, rhs) => {
                write!(writer, "{rt}::Either<", rt = RT_NAME)?;
                emit_ty(writer, lhs)?;
                write!(writer, ", ")?;
                emit_ty(writer, rhs)?;
                write!(writer, ">")
            }
            RtType::U8 => write!(writer, "{rt}::U8", rt = RT_NAME),
            RtType::U16Le => write!(writer, "{rt}::U16Le", rt = RT_NAME),
            RtType::U16Be => write!(writer, "{rt}::U16Be", rt = RT_NAME),
            RtType::U32Le => write!(writer, "{rt}::U32Le", rt = RT_NAME),
            RtType::U32Be => write!(writer, "{rt}::U32Be", rt = RT_NAME),
            RtType::U64Le => write!(writer, "{rt}::U64Le", rt = RT_NAME),
            RtType::U64Be => write!(writer, "{rt}::U64Be", rt = RT_NAME),
            RtType::I8 => write!(writer, "{rt}::I8", rt = RT_NAME),
            RtType::I16Le => write!(writer, "{rt}::I16Le", rt = RT_NAME),
            RtType::I16Be => write!(writer, "{rt}::I16Be", rt = RT_NAME),
            RtType::I32Le => write!(writer, "{rt}::I32Le", rt = RT_NAME),
            RtType::I32Be => write!(writer, "{rt}::I32Be", rt = RT_NAME),
            RtType::I64Le => write!(writer, "{rt}::I64Le", rt = RT_NAME),
            RtType::I64Be => write!(writer, "{rt}::I64Be", rt = RT_NAME),
            RtType::F32Le => write!(writer, "{rt}::F32Le", rt = RT_NAME),
            RtType::F32Be => write!(writer, "{rt}::F32Be", rt = RT_NAME),
            RtType::F64Le => write!(writer, "{rt}::F64Le", rt = RT_NAME),
            RtType::F64Be => write!(writer, "{rt}::F64Be", rt = RT_NAME),
            RtType::InvalidDataDescription => {
                write!(writer, "{rt}::InvalidDataDescription", rt = RT_NAME)
            }
        },
    }
}

fn emit_ty_read(writer: &mut impl Write, ty: &Type) -> io::Result<()> {
    match ty {
        Type::Var(name) => write!(writer, "reader.read::<{}>()?", name),
        Type::If(cond, lhs, rhs) => {
            write!(writer, "if ")?;
            emit_term(writer, cond)?;
            write!(writer, " {{ {rt}::Either::Left(", rt = RT_NAME)?;
            emit_ty_read(writer, lhs)?;
            write!(writer, ") }} else {{ {rt}::Either::Right(", rt = RT_NAME)?;
            emit_ty_read(writer, rhs)?;
            write!(writer, ") }}")
        }
        Type::Rt(rt_ty) => match rt_ty {
            RtType::Either(_, _) => write!(
                writer,
                "reader.read::<{rt}::InvalidDataDescription>()?",
                rt = RT_NAME,
            ),
            RtType::U8 => write!(writer, "reader.read::<{rt}::U8>()?", rt = RT_NAME),
            RtType::U16Le => write!(writer, "reader.read::<{rt}::U16Le>()?", rt = RT_NAME),
            RtType::U16Be => write!(writer, "reader.read::<{rt}::U16Be>()?", rt = RT_NAME),
            RtType::U32Le => write!(writer, "reader.read::<{rt}::U32Le>()?", rt = RT_NAME),
            RtType::U32Be => write!(writer, "reader.read::<{rt}::U32Be>()?", rt = RT_NAME),
            RtType::U64Le => write!(writer, "reader.read::<{rt}::U64Le>()?", rt = RT_NAME),
            RtType::U64Be => write!(writer, "reader.read::<{rt}::U64Be>()?", rt = RT_NAME),
            RtType::I8 => write!(writer, "reader.read::<{rt}::I8>()?", rt = RT_NAME),
            RtType::I16Le => write!(writer, "reader.read::<{rt}::I16Le>()?", rt = RT_NAME),
            RtType::I16Be => write!(writer, "reader.read::<{rt}::I16Be>()?", rt = RT_NAME),
            RtType::I32Le => write!(writer, "reader.read::<{rt}::I32Le>()?", rt = RT_NAME),
            RtType::I32Be => write!(writer, "reader.read::<{rt}::I32Be>()?", rt = RT_NAME),
            RtType::I64Le => write!(writer, "reader.read::<{rt}::I64Le>()?", rt = RT_NAME),
            RtType::I64Be => write!(writer, "reader.read::<{rt}::I64Be>()?", rt = RT_NAME),
            RtType::F32Le => write!(writer, "reader.read::<{rt}::F32Le>()?", rt = RT_NAME),
            RtType::F32Be => write!(writer, "reader.read::<{rt}::F32Be>()?", rt = RT_NAME),
            RtType::F64Le => write!(writer, "reader.read::<{rt}::F64Le>()?", rt = RT_NAME),
            RtType::F64Be => write!(writer, "reader.read::<{rt}::F64Be>()?", rt = RT_NAME),
            RtType::InvalidDataDescription => write!(
                writer,
                "reader.read::<{rt}::InvalidDataDescription>()?",
                rt = RT_NAME,
            ),
        },
        _ => unimplemented!("unexpected host type"),
    }
}

fn emit_term(writer: &mut impl Write, term: &Term) -> io::Result<()> {
    match term {
        Term::Var(name) => write!(writer, "{}", name),
        Term::Bool(value) => write!(writer, "{}", value),
        Term::U8(value) => write!(writer, "{}u8", value),
        Term::U16(value) => write!(writer, "{}u16", value),
        Term::U32(value) => write!(writer, "{}u32", value),
        Term::U64(value) => write!(writer, "{}u64", value),
        Term::I8(value) => write!(writer, "{}i8", value),
        Term::I16(value) => write!(writer, "{}i16", value),
        Term::I32(value) => write!(writer, "{}i32", value),
        Term::I64(value) => write!(writer, "{}i64", value),
        Term::F32(value) => write!(writer, "{}f32", value),
        Term::F64(value) => write!(writer, "{}f64", value),
        Term::Call(term) => {
            emit_term(writer, term)?;
            write!(writer, "()")
        }
        Term::If(term0, term1, term2) => {
            write!(writer, "if ")?;
            emit_term(writer, term0)?;
            write!(writer, " {{ ")?;
            emit_term(writer, term1)?;
            write!(writer, " }} else {{ ")?;
            emit_term(writer, term2)?;
            write!(writer, " }}")
        }
    }
}
