use syntax::{Definition, Field};
use syntax::binary::{SpannedType, SpannedTypeRec, TypeF};
use syntax::host::{Binop, ExprF, SpannedExpr, SpannedExprRec, Unop};
use parser::lexer::{Token, Error as LexerError};
use source::{BytePos, Span};


grammar<'input>();


// Tokens

extern {
    type Location = BytePos;
    type Error = LexerError;

    enum Token<'input> {
        // Data
        "Ident" => Token::Ident(<&'input str>),
        "BinLiteral" => Token::BinLiteral(<i64>),
        "HexLiteral" => Token::HexLiteral(<i64>),
        "DecLiteral" => Token::DecLiteral(<i64>),

        // Keywords
        "struct" => Token::Struct,
        "union" => Token::Union,
        "where" => Token::Where,

        // Symbols
        "&" => Token::Ampersand,
        "!" => Token::Bang,
        "!=" => Token::BangEqual,
        ":" => Token::Colon,
        "," => Token::Comma,
        "=" => Token::Equal,
        "==" => Token::EqualEqual,
        "=>" => Token::EqualGreater,
        "/" => Token::ForwardSlash,
        ">" => Token::Greater,
        ">=" => Token::GreaterEqual,
        "<" => Token::Less,
        "<=" => Token::LessEqual,
        "-" => Token::Minus,
        "|" => Token::Pipe,
        "+" => Token::Plus,
        ";" => Token::Semi,
        "*" => Token::Star,

        // Delimeters
        "(" => Token::LParen,
        ")" => Token::RParen,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        "[" => Token::LBracket,
        "]" => Token::RBracket,
    }
}


pub Definitions: Vec<Definition<String, SpannedType<String, SpannedExpr<String>>>> = {
    Definition*,
};

Definition: Definition<String, SpannedType<String, SpannedExpr<String>>> = {
    <name: "Ident"> "=" <ty: SpannedType<PrimaryType>> ";" => {
        Definition::new(name, ty)
    },
};

Field: Field<String, SpannedType<String, SpannedExpr<String>>> = {
    <name: "Ident"> ":" <ty: SpannedType<PrimaryType>> => {
        Field::new(name, ty)
    },
};


// Types

pub Type: SpannedType<String, SpannedExpr<String>> = {
    <ty: SpannedType<PrimaryType>> => ty,
};

SpannedType<T>: SpannedType<String, SpannedExpr<String>> = {
    <lo: @L> <inner: T> <hi: @R> => {
        SpannedType { span: Span::new(lo, hi), inner }
    }
};

PrimaryType: SpannedTypeRec<String, SpannedExpr<String>> = {
    AtomicType,
    <ty: SpannedType<PrimaryType>> "where" <param: "Ident"> "=>" <pred: SpannedExpr<PrimaryExpr>> => {
        TypeF::cond(ty, param, pred)
    },
};

AtomicType: SpannedTypeRec<String, SpannedExpr<String>> = {
    <name: "Ident"> => {
        TypeF::fvar(name)
    },
    "(" <ty: PrimaryType> ")" => ty,
    "struct" "{" <fields: (<Field> ",")*> <last: Field?> "}" => {
        TypeF::struct_(fields.into_iter().chain(last))
    },
    "union" "{" <tys: (<SpannedType<PrimaryType>> ",")+> <last: SpannedType<PrimaryType>?> "}" => {
        let mut tys = tys;
        tys.extend(last);
        TypeF::union(tys)
    },
    "[" <elem: SpannedType<PrimaryType>> ";" <size: SpannedExpr<PrimaryExpr>> "]" => {
        TypeF::array(elem, size)
    },
};


// Expressions

pub Expr: SpannedExpr<String> = {
    <expr: SpannedExpr<PrimaryExpr>> => expr,
};

SpannedExpr<E>: SpannedExpr<String> = {
    <lo: @L> <inner: E> <hi: @R> => {
        SpannedExpr { span: Span::new(lo, hi), inner }
    }
};

// Use precedence climbing to define the operators
// https://en.wikipedia.org/wiki/Operator-precedence_parser#Precedence_climbing_method

PrimaryExpr: SpannedExprRec<String> = {
    EqExpr,
    <lhs: SpannedExpr<EqExpr>> "|" <rhs: SpannedExpr<PrimaryExpr>> => {
        ExprF::binop(Binop::Or, lhs, rhs)
    },
    <lhs: SpannedExpr<EqExpr>> "&" <rhs: SpannedExpr<PrimaryExpr>> => {
        ExprF::binop(Binop::And, lhs, rhs)
    },
};

EqExpr: SpannedExprRec<String> = {
    CmpExpr,
    <lhs: SpannedExpr<CmpExpr>> "==" <rhs: SpannedExpr<EqExpr>> => {
        ExprF::binop(Binop::Eq, lhs, rhs)
    },
    <lhs: SpannedExpr<CmpExpr>> "!=" <rhs: SpannedExpr<EqExpr>> => {
        ExprF::binop(Binop::Ne, lhs, rhs)
    },
};

CmpExpr: SpannedExprRec<String> = {
    AddExpr,
    <lhs: SpannedExpr<AddExpr>> "<=" <rhs: SpannedExpr<CmpExpr>> => {
        ExprF::binop(Binop::Le, lhs, rhs)
    },
    <lhs: SpannedExpr<AddExpr>> "<" <rhs: SpannedExpr<CmpExpr>> => {
        ExprF::binop(Binop::Lt, lhs, rhs)
    },
    <lhs: SpannedExpr<AddExpr>> ">" <rhs: SpannedExpr<CmpExpr>> => {
        ExprF::binop(Binop::Gt, lhs, rhs)
    },
    <lhs: SpannedExpr<AddExpr>> ">=" <rhs: SpannedExpr<CmpExpr>> => {
        ExprF::binop(Binop::Ge, lhs, rhs)
    },
};

AddExpr: SpannedExprRec<String> = {
    MulExpr,
    <lhs: SpannedExpr<MulExpr>> "+" <rhs: SpannedExpr<AddExpr>> => {
        ExprF::binop(Binop::Add, lhs, rhs)
    },
    <lhs: SpannedExpr<MulExpr>> "-" <rhs: SpannedExpr<AddExpr>> => {
        ExprF::binop(Binop::Sub, lhs, rhs)
    },
};

MulExpr: SpannedExprRec<String> = {
    AtomicExpr,
    <lhs: SpannedExpr<AtomicExpr>> "*" <rhs: SpannedExpr<MulExpr>> => {
        ExprF::binop(Binop::Mul, lhs, rhs)
    },
    <lhs: SpannedExpr<AtomicExpr>> "/" <rhs: SpannedExpr<MulExpr>> => {
        ExprF::binop(Binop::Div, lhs, rhs)
    },
};

AtomicExpr: SpannedExprRec<String> = {
    "(" <expr: PrimaryExpr> ")" => expr,
    <value: "BinLiteral"> => {
        ExprF::int(value)
    },
    <value: "HexLiteral"> => {
        ExprF::int(value)
    },
    <value: "DecLiteral"> => {
        ExprF::int(value)
    },
    <name: "Ident"> => {
        ExprF::fvar(name)
    },
    "-" <expr: SpannedExpr<AtomicExpr>> => {
        ExprF::unop(Unop::Neg, expr)
    },
    "!" <value: SpannedExpr<AtomicExpr>> => {
        ExprF::unop(Unop::Not, value)
    },
};
