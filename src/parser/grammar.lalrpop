use std::str::FromStr;

use ast::{Definition, Field, Expr, Type};
use env::Env;
use source::BytePos as Bp;

grammar(env: &Env);

pub Definitions: Vec<Definition> = {
    Definition*,
};

Definition: Definition = {
    <lo: @L> <name: Ident> "=" <ty: Type> ";" <hi: @R> => {
        Definition::new((Bp(lo), Bp(hi)), name, ty)
    },
};

Ident: &'input str = {
    r"[_a-zA-Z][_a-zA-Z0-9]*",
};

AtomicType: Type = {
    <lo: @L> <name: Ident> <hi: @R> => {
        match env.lookup_ty(&name) {
            Some(ty) => ty.clone(),
            None => Type::ident((Bp(lo), Bp(hi)), name),
        }
    },
    "(" <Type> ")",
    <lo: @L> "{" <fields: (<Field> ",")*> <last: Field?> "}" <hi: @R> => {
        let mut fields = fields;
        fields.extend(last);
        Type::struct_((Bp(lo), Bp(hi)), fields)
    },
    <lo: @L> "[" <elem: Type> ";" <size: Expr> "]" <hi: @R> => {
        Type::array((Bp(lo), Bp(hi)), Box::new(elem), size)
    },
};

pub Type: Type = {
    AtomicType,
    <lo: @L> "|"? <tys: (<AtomicType> "|")+> <last: AtomicType> <hi: @R> => {
        let mut tys = tys;
        tys.push(last);
        Type::union((Bp(lo), Bp(hi)), tys)
    },
};

pub Expr: Expr = {
    <lo: @L> <value: Num> <hi: @R> => {
        Expr::const_((Bp(lo), Bp(hi)), value)
    },
    <lo: @L> <name: Ident> <hi: @R> => {
        Expr::var((Bp(lo), Bp(hi)), name)
    },
};

Num: u32 = {
    r"[0-9]+" => u32::from_str(<>).unwrap(),
};

Field: Field = {
    <lo: @L> <name: Ident> ":" <ty: Type> <hi: @R> => {
        Field::new((Bp(lo), Bp(hi)), name, ty)
    },
};
