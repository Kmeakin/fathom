use lalrpop_util::ParseError;
use codespan::{BytePos, Span};
use parser::ast::{Binop, Const, Definition, Expr, Field, Module, Type, TypeConst, Unop};
use parser::GrammarError;
use parser::lexer::Token;


grammar<'src>();


// Tokens

extern {
    type Location = BytePos;
    type Error = GrammarError;

    enum Token<'src> {
        // Data
        "Ident" => Token::Ident(<&'src str>),
        "DocComment" => Token::DocComment(<&'src str>),
        "BinLiteral" => Token::BinLiteral(<u64>, <&'src str>),
        "HexLiteral" => Token::HexLiteral(<u64>, <&'src str>),
        "DecLiteral" => Token::DecLiteral(<u64>, <&'src str>),
        "FloatDecLiteral" => Token::FloatDecLiteral(<f64>, <&'src str>),

        // Keywords
        "as" => Token::As,
        "cond" => Token::Cond,
        "compute" => Token::Compute,
        "from" => Token::From,
        "struct" => Token::Struct,
        "union" => Token::Union,
        "where" => Token::Where,

        // Symbols
        "&" => Token::Amp,
        "&&" => Token::AmpAmp,
        "!" => Token::Bang,
        "!=" => Token::BangEqual,
        ":" => Token::Colon,
        "," => Token::Comma,
        "." => Token::Dot,
        "=" => Token::Equal,
        "==" => Token::EqualEqual,
        "=>" => Token::EqualGreater,
        "/" => Token::ForwardSlash,
        ">" => Token::Greater,
        ">=" => Token::GreaterEqual,
        "<" => Token::Less,
        "<=" => Token::LessEqual,
        "-" => Token::Minus,
        "|" => Token::Pipe,
        "||" => Token::PipePipe,
        "+" => Token::Plus,
        ";" => Token::Semi,
        "*" => Token::Star,

        // Delimeters
        "(" => Token::LParen,
        ")" => Token::RParen,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        "[" => Token::LBracket,
        "]" => Token::RBracket,
    }
}


pub Module: Module<'src> = {
    Definition* => Module { definitions: <> }
};

pub Definition: Definition<'src> = {
    <doc: "DocComment"*>
        <lo: @L> <name: "Ident"> "="
        <body_ty: PrimaryType> ";" <hi: @R> =>
    {
        Definition { doc, name, span: Span::new(lo, hi), param_names: vec![], body_ty }
    },
    <doc: "DocComment"*>
        <lo: @L> <name: "Ident"> "(" <param_names: (<"Ident"> ",")*> <last: "Ident"> ")" "="
        <body_ty: PrimaryType> <hi: @R> ";" =>
    {
        Definition {
            doc,
            name,
            span: Span::new(lo, hi),
            param_names: super::extend_vec(param_names, Some(last)),
            body_ty,
        }
    },
};

Field<Value>: Field<'src, Value> = {
    <doc: "DocComment"*> <name: "Ident"> ":" <value: Value> => {
        Field { doc, name, value }
    },
};


// Types

pub Type: Type<'src> = {
    <ty: PrimaryType> => ty,
};

PrimaryType: Type<'src> = {
    AtomicType,
    <lo1: @L> <ty: PrimaryType> "where" <lo2: @L> <param: "Ident"> "=>" <pred: PrimaryExpr> <hi: @R> => {
        Type::Where(Span::new(lo1, hi), Box::new(ty), lo2, param, Box::new(pred))
    },
    <lo: @L> "compute" <repr_ty: HostType> "from" <expr: PrimaryExpr> <hi: @R> => {
        Type::Compute(Span::new(lo, hi), repr_ty, Box::new(expr))
    },
};

AtomicType: Type<'src> = {
    <lo: @L> <name: "Ident"> <hi: @R> => {
        Type::Var(Span::new(lo, hi), name)
    },
    <lo: @L> <ty: AtomicType> "(" <arg_tys: (<Type> ",")*> <last: Type> ")" <hi: @R> => {
        Type::App(Span::new(lo, hi), Box::new(ty), super::extend_vec(arg_tys, Some(last)))
    },
    "(" <ty: PrimaryType> ")" => ty,
    <lo: @L> "struct" "{"
        <fields: (<Field<Type>> ",")*>
        <last: Field<Type>?>
    "}" <hi: @R> =>
    {
        Type::Struct(Span::new(lo, hi), super::extend_vec(fields, last))
    },
    <lo: @L> "cond" "{"
        <options: (<Field<(<Expr> "=>" <Type>)>> ",")*>
        <last: Field<(<Expr> "=>" <Type>)>?>
    "}" <hi: @R> =>
    {
        Type::Cond(Span::new(lo, hi), super::extend_vec(options, last))
    },
    <lo: @L> "[" <elem: PrimaryType> ";" <size: PrimaryExpr> "]" <hi: @R> => {
        Type::Array(Span::new(lo, hi), Box::new(elem), Box::new(size))
    },
};


// Host Types

HostType: TypeConst = {
    // FIXME: implement full host type parsing, with proper name binding
    //
    // We'll just hard-code identifiers for now
    <name: "Ident"> =>? {
        use syntax::ast::{FloatType, SignedType, UnsignedType};

        match name {
            "unit" => Ok(TypeConst::Unit),
            "bottom" => Ok(TypeConst::Bottom),
            "bool" => Ok(TypeConst::Bool),
            "f32" => Ok(TypeConst::Float(FloatType::F32)),
            "f64" => Ok(TypeConst::Float(FloatType::F64)),
            "i8" => Ok(TypeConst::Signed(SignedType::I8)),
            "i16" => Ok(TypeConst::Signed(SignedType::I16)),
            "i24" => Ok(TypeConst::Signed(SignedType::I24)),
            "i32" => Ok(TypeConst::Signed(SignedType::I32)),
            "i64" => Ok(TypeConst::Signed(SignedType::I64)),
            "u8" => Ok(TypeConst::Unsigned(UnsignedType::U8)),
            "u16" => Ok(TypeConst::Unsigned(UnsignedType::U16)),
            "u24" => Ok(TypeConst::Unsigned(UnsignedType::U24)),
            "u32" => Ok(TypeConst::Unsigned(UnsignedType::U32)),
            "u64" => Ok(TypeConst::Unsigned(UnsignedType::U64)),
            name => Err(ParseError::User {
                error: GrammarError::InvalidHostTypeName { name: name.to_owned() },
            }),
        }
    },
};


// Expressions

pub Expr: Expr<'src> = {
    <expr: PrimaryExpr> => expr,
};

// Unary operators

UnopNeg: Unop = "-" => Unop::Neg;
UnopNot: Unop = "!" => Unop::Not;

UnopExpr<Op, Operand>: Expr<'src> = {
    <lo: @L> <op: Op> <expr: Operand> <hi: @R> => {
        Expr::Unop(Span::new(lo, hi), op, Box::new(expr))
    },
};

// Binary operators

BinopOr:   Binop = "||"  => Binop::Or;
BinopAnd:  Binop = "&&"  => Binop::And;
BinopEq:   Binop = "=="  => Binop::Eq;
BinopNe:   Binop = "!="  => Binop::Ne;
BinopLe:   Binop = "<="  => Binop::Le;
BinopLt:   Binop = "<"   => Binop::Lt;
BinopGt:   Binop = ">"   => Binop::Gt;
BinopGe:   Binop = ">="  => Binop::Ge;
BinopAdd:  Binop = "+"   => Binop::Add;
BinopSub:  Binop = "-"   => Binop::Sub;
BinopMul:  Binop = "*"   => Binop::Mul;
BinopDiv:  Binop = "/"   => Binop::Div;

BinopExpr<Lhs, Op, Rhs>: Expr<'src> = {
    <lo: @L> <lhs: Lhs> <op: Op> <rhs: Rhs> <hi: @R> => {
        Expr::Binop(Span::new(lo, hi), op, Box::new(lhs), Box::new(rhs))
    },
};

// Use precedence climbing to define the operators
// https://en.wikipedia.org/wiki/Operator-precedence_parser#Precedence_climbing_method

PrimaryExpr: Expr<'src> = {
    EqExpr,
    BinopExpr<EqExpr, BinopOr, PrimaryExpr>,
    BinopExpr<EqExpr, BinopAnd, PrimaryExpr>,
};

EqExpr: Expr<'src> = {
    CmpExpr,
    BinopExpr<CmpExpr, BinopEq, EqExpr>,
    BinopExpr<CmpExpr, BinopNe, EqExpr>,
};

CmpExpr: Expr<'src> = {
    AddExpr,
    BinopExpr<AddExpr, BinopLe, CmpExpr>,
    BinopExpr<AddExpr, BinopLt, CmpExpr>,
    BinopExpr<AddExpr, BinopGt, CmpExpr>,
    BinopExpr<AddExpr, BinopGe, CmpExpr>,
};

AddExpr: Expr<'src> = {
    MulExpr,
    BinopExpr<MulExpr, BinopAdd, AddExpr>,
    BinopExpr<MulExpr, BinopSub, AddExpr>,
};

MulExpr: Expr<'src> = {
    CastExpr,
    BinopExpr<CastExpr, BinopMul, MulExpr>,
    BinopExpr<CastExpr, BinopDiv, MulExpr>,
};

CastExpr: Expr<'src> = {
    AnnExpr,
    <lo: @L> <expr: CastExpr> "as" <ty: HostType> <hi: @R> => {
        Expr::Cast(Span::new(lo, hi), Box::new(expr), ty)
    },
};

AnnExpr: Expr<'src> = {
    PrefixExpr,
    <lo: @L> <expr: AnnExpr> ":" <ty: HostType> <hi: @R> => {
        Expr::Ann(Span::new(lo, hi), Box::new(expr), ty)
    },
};

PrefixExpr: Expr<'src> = {
    AtomicExpr,
    UnopExpr<UnopNeg, AtomicExpr>,
    UnopExpr<UnopNot, AtomicExpr>,
};

IntLiteral<Value>: Expr<'src> = {
    <lo: @L> <value: Value> <hi: @R> =>? {
        use syntax::ast::{IntSuffix, SignedType, UnsignedType};

        let float = Const::Int(value.0, match value.1 {
            "i8" => IntSuffix::Signed(SignedType::I8),
            "i16" => IntSuffix::Signed(SignedType::I16),
            "i24" => IntSuffix::Signed(SignedType::I24),
            "i32" => IntSuffix::Signed(SignedType::I32),
            "i64" => IntSuffix::Signed(SignedType::I64),
            "u8" => IntSuffix::Unsigned(UnsignedType::U8),
            "u16" => IntSuffix::Unsigned(UnsignedType::U16),
            "u24" => IntSuffix::Unsigned(UnsignedType::U24),
            "u32" => IntSuffix::Unsigned(UnsignedType::U32),
            "u64" => IntSuffix::Unsigned(UnsignedType::U64),
            "" => return Err(ParseError::User { error: GrammarError::ConstSuffixMissing }),
            suffix => return Err(ParseError::User {
                error: GrammarError::ConstSuffixInvalid { suffix: suffix.to_owned() },
            }),
        });

        Ok(Expr::Const(Span::new(lo, hi), float))
    },
};

FloatLiteral<Value>: Expr<'src> = {
    <lo: @L> <value: Value> <hi: @R> =>? {
        use syntax::ast::FloatType;

        let float = Const::Float(value.0, match value.1 {
            "f32" => FloatType::F32,
            "f64" => FloatType::F64,
            "" => return Err(ParseError::User { error: GrammarError::ConstSuffixMissing }),
            suffix => return Err(ParseError::User {
                error: GrammarError::ConstSuffixInvalid { suffix: suffix.to_owned() },
            }),
        });

        Ok(Expr::Const(Span::new(lo, hi), float))
    },
};

AtomicExpr: Expr<'src> = {
    "(" <expr: PrimaryExpr> ")" => expr,

    <lo: @L> "[" <elems: (<PrimaryExpr> ",")*> <last: PrimaryExpr?> "]" <hi: @R> => {
        Expr::Array(Span::new(lo, hi), super::extend_vec(elems, last))
    },

    IntLiteral<"BinLiteral">,
    IntLiteral<"HexLiteral">,
    IntLiteral<"DecLiteral">,
    FloatLiteral<"FloatDecLiteral">,
    <lo: @L> <name: "Ident"> <hi: @R> => {
        Expr::Var(Span::new(lo, hi), name)
    },
    <lo: @L> <struct_expr: AtomicExpr> "." <field_name: "Ident"> <hi: @R> => {
        Expr::Proj(Span::new(lo, hi), Box::new(struct_expr), field_name)
    },
    <lo: @L> <array_expr: AtomicExpr> "[" <index_expr: PrimaryExpr> "]" <hi: @R> => {
        Expr::Subscript(Span::new(lo, hi), Box::new(array_expr), Box::new(index_expr))
    },
};
