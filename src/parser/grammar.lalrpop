use ast::{Binop, Definition, Field, Expr, Type, Unop};
use env::Env;
use parser::lexer::{Token, Error as LexerError};
use source::BytePos;

grammar<'input, 'env>(env: &'env Env);

extern {
    type Location = BytePos;
    type Error = LexerError;

    enum Token<'input> {
        // Data
        "Ident" => Token::Ident(<&'input str>),
        "BinLiteral" => Token::BinLiteral(<i64>),
        "HexLiteral" => Token::HexLiteral(<i64>),
        "DecLiteral" => Token::DecLiteral(<i64>),

        // Keywords
        "struct" => Token::Struct,
        "union" => Token::Union,
        "where" => Token::Where,

        // Symbols
        "&" => Token::Ampersand,
        "!" => Token::Bang,
        "!=" => Token::BangEqual,
        ":" => Token::Colon,
        "," => Token::Comma,
        "=" => Token::Equal,
        "==" => Token::EqualEqual,
        "=>" => Token::EqualGreater,
        "/" => Token::ForwardSlash,
        ">" => Token::Greater,
        ">=" => Token::GreaterEqual,
        "<" => Token::Less,
        "<=" => Token::LessEqual,
        "-" => Token::Minus,
        "|" => Token::Pipe,
        "+" => Token::Plus,
        ";" => Token::Semi,
        "*" => Token::Star,

        // Delimeters
        "(" => Token::LParen,
        ")" => Token::RParen,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        "[" => Token::LBracket,
        "]" => Token::RBracket,
    }
}

pub Definitions: Vec<Definition> = {
    Definition*,
};

Definition: Definition = {
    <lo: @L> <name: "Ident"> "=" <ty: Type> ";" <hi: @R> => {
        Definition::new((lo, hi), name, ty)
    },
};

AtomicType: Type = {
    <lo: @L> <name: "Ident"> <hi: @R> => {
        match env.lookup_ty(&name) {
            Some(ty) => ty.clone(),
            None => Type::var((lo, hi), name),
        }
    },
    "(" <Type> ")",
    <lo: @L> "struct" "{" <fields: (<Field> ",")*> <last: Field?> "}" <hi: @R> => {
        let mut fields = fields;
        fields.extend(last);
        Type::struct_((lo, hi), fields)
    },
    <lo: @L> "union" "{" <tys: (<Type> ",")+> <last: Type?> "}" <hi: @R> => {
        let mut tys = tys;
        tys.extend(last);
        Type::union((lo, hi), tys)
    },
    <lo: @L> "[" <elem: Type> ";" <size: Expr> "]" <hi: @R> => {
        Type::array((lo, hi), elem, size)
    },
};

pub Type: Type = {
    AtomicType,
    <lo: @L> <ty: Type> "where" <param: "Ident"> "=>" <pred: Expr> <hi: @R> => {
        Type::where_((lo, hi), ty, param, pred)
    },
};

// Use precedence climbing to define the operators
// https://en.wikipedia.org/wiki/Operator-precedence_parser#Precedence_climbing_method

pub Expr: Expr = {
    EqExpr,
    <lo: @L> <lhs: EqExpr> "|" <rhs: Expr> <hi: @R> => {
        Expr::binop((lo, hi), Binop::Or, lhs, rhs)
    },
    <lo: @L> <lhs: EqExpr> "&" <rhs: Expr> <hi: @R> => {
        Expr::binop((lo, hi), Binop::And, lhs, rhs)
    },
};

EqExpr: Expr = {
    CmpExpr,
    <lo: @L> <lhs: CmpExpr> "==" <rhs: EqExpr> <hi: @R> => {
        Expr::binop((lo, hi), Binop::Eq, lhs, rhs)
    },
    <lo: @L> <lhs: CmpExpr> "!=" <rhs: EqExpr> <hi: @R> => {
        Expr::binop((lo, hi), Binop::Ne, lhs, rhs)
    },
};

CmpExpr: Expr = {
    AddExpr,
    <lo: @L> <lhs: AddExpr> "<=" <rhs: CmpExpr> <hi: @R> => {
        Expr::binop((lo, hi), Binop::Le, lhs, rhs)
    },
    <lo: @L> <lhs: AddExpr> "<" <rhs: CmpExpr> <hi: @R> => {
        Expr::binop((lo, hi), Binop::Lt, lhs, rhs)
    },
    <lo: @L> <lhs: AddExpr> ">" <rhs: CmpExpr> <hi: @R> => {
        Expr::binop((lo, hi), Binop::Gt, lhs, rhs)
    },
    <lo: @L> <lhs: AddExpr> ">=" <rhs: CmpExpr> <hi: @R> => {
        Expr::binop((lo, hi), Binop::Ge, lhs, rhs)
    },
};

AddExpr : Expr = {
    MulExpr,
    <lo: @L> <lhs: MulExpr> "+" <rhs: AddExpr> <hi: @R> => {
        Expr::binop((lo, hi), Binop::Add, lhs, rhs)
    },
    <lo: @L> <lhs: MulExpr> "-" <rhs: AddExpr> <hi: @R> => {
        Expr::binop((lo, hi), Binop::Sub, lhs, rhs)
    },
};

MulExpr : Expr = {
    AtomicExpr,
    <lo: @L> <lhs: AtomicExpr> "*" <rhs: MulExpr> <hi: @R> => {
        Expr::binop((lo, hi), Binop::Mul, lhs, rhs)
    },
    <lo: @L> <lhs: AtomicExpr> "/" <rhs: MulExpr> <hi: @R> => {
        Expr::binop((lo, hi), Binop::Div, lhs, rhs)
    },
};

AtomicExpr : Expr = {
    "(" <expr: Expr> ")" => expr,
    <lo: @L> <value: "BinLiteral"> <hi: @R> => {
        Expr::int((lo, hi), value)
    },
    <lo: @L> <value: "HexLiteral"> <hi: @R> => {
        Expr::int((lo, hi), value)
    },
    <lo: @L> <value: "DecLiteral"> <hi: @R> => {
        Expr::int((lo, hi), value)
    },
    <lo: @L> <name: "Ident"> <hi: @R> => {
        match name {
            "true" => Expr::bool((lo, hi), true),
            "false" => Expr::bool((lo, hi), false),
            name => Expr::var((lo, hi), name),
        }
    },
    <lo: @L> "-" <expr: AtomicExpr> <hi: @R> => {
        Expr::unop((lo, hi), Unop::Neg, expr)
    },
    <lo: @L> "!" <value: AtomicExpr> <hi: @R> => {
        Expr::unop((lo, hi), Unop::Not, value)
    },
};

Field: Field = {
    <lo: @L> <name: "Ident"> ":" <ty: Type> <hi: @R> => {
        Field::new((lo, hi), name, ty)
    },
};
