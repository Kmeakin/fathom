use std::iter;

use lalrpop_util::ParseError::User as UserError;
use name::Named;
use source::{BytePos, Span};
use syntax::ast::{Definition, Field, Program};
use syntax::ast::binary::{RcType, Type};
use syntax::ast::host::{Binop, Const, Expr, RcExpr, Unop};
use syntax::parser::GrammarError;
use syntax::parser::lexer::Token;


grammar<'input>();


// Tokens

extern {
    type Location = BytePos;
    type Error = GrammarError;

    enum Token<'input> {
        // Data
        "Ident" => Token::Ident(<&'input str>),
        "DocComment" => Token::DocComment(<&'input str>),
        "BinLiteral" => Token::BinLiteral(<u64>, <&'input str>),
        "HexLiteral" => Token::HexLiteral(<u64>, <&'input str>),
        "DecLiteral" => Token::DecLiteral(<u64>, <&'input str>),

        // Keywords
        "struct" => Token::Struct,
        "union" => Token::Union,
        "where" => Token::Where,

        // Symbols
        "&" => Token::Ampersand,
        "!" => Token::Bang,
        "!=" => Token::BangEqual,
        ":" => Token::Colon,
        "," => Token::Comma,
        "." => Token::Dot,
        "=" => Token::Equal,
        "==" => Token::EqualEqual,
        "=>" => Token::EqualGreater,
        "/" => Token::ForwardSlash,
        ">" => Token::Greater,
        ">=" => Token::GreaterEqual,
        "<" => Token::Less,
        "<=" => Token::LessEqual,
        "-" => Token::Minus,
        "|" => Token::Pipe,
        "+" => Token::Plus,
        ";" => Token::Semi,
        "*" => Token::Star,

        // Delimeters
        "(" => Token::LParen,
        ")" => Token::RParen,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        "[" => Token::LBracket,
        "]" => Token::RBracket,
    }
}


pub Program: Program<String> = {
    <defs: Definition*> => {
        Program::new(defs)
    },
};

Definition: Definition<String> = {
    <doc: "DocComment"*> <name: "Ident"> "=" <ty: PrimaryType> ";" => {
        Definition::new(doc.join("\n"), name, ty)
    },
    <doc: "DocComment"*> <name: "Ident"> <lo: @L>
        "(" <params: (<"Ident"> ",")*> <last: "Ident"> ")" "="
        <ty: PrimaryType> <hi: @R> ";" =>
    {
        let params = params.into_iter()
            .chain(iter::once(last))
            .map(|p| p.to_owned())
            .collect::<Vec<String>>();

        Definition::new(doc.join("\n"), name, Type::abs(Span::new(lo, hi), &params, ty))
    },
};

Field: Field<String, RcType<String>> = {
    <doc: "DocComment"*> <name: "Ident"> ":" <ty: PrimaryType> => {
        Field::new(doc.join("\n"), name, ty)
    },
};


// Types

pub Type: RcType<String> = {
    <ty: PrimaryType> => ty,
};

PrimaryType: RcType<String> = {
    AtomicType,
    <lo1: @L> <ty: PrimaryType> "where" <lo2: @L> <param: "Ident"> "=>" <pred: PrimaryExpr> <hi: @R> => {
        let repr_ty = ty.repr();
        let pred_expr = Expr::abs(
            Span::new(lo2, hi),
            vec![Named(param.to_owned(), repr_ty)],
            pred,
        );

        Type::assert(Span::new(lo1, hi), ty, pred_expr).into()
    },
};

AtomicType: RcType<String> = {
    <lo: @L> <name: "Ident"> <hi: @R> => {
        Type::fvar(Span::new(lo, hi), name).into()
    },
    <lo: @L> <ty: AtomicType> "(" <arg_tys: (<Type> ",")*> <last: Type> ")" <hi: @R> => {
        let mut arg_tys = arg_tys;
        arg_tys.push(last);
        Type::app(Span::new(lo, hi), ty, arg_tys).into()
    },
    "(" <ty: PrimaryType> ")" => ty,
    <lo: @L> "struct" "{" <fields: (<Field> ",")*> <last: Field?> "}" <hi: @R> => {
        let mut fields = fields;
        fields.extend(last);
        Type::struct_(Span::new(lo, hi), fields).into()
    },
    <lo: @L> "union" "{" <variants: (<Field> ",")*> <last: Field?> "}" <hi: @R> => {
        let mut variants = variants;
        variants.extend(last);
        Type::union(Span::new(lo, hi), variants).into()
    },
    <lo: @L> "[" <elem: PrimaryType> ";" <size: PrimaryExpr> "]" <hi: @R> => {
        Type::array(Span::new(lo, hi), elem, size).into()
    },
};


// Expressions

pub Expr: RcExpr<String> = {
    <expr: PrimaryExpr> => expr,
};

// Use precedence climbing to define the operators
// https://en.wikipedia.org/wiki/Operator-precedence_parser#Precedence_climbing_method

PrimaryExpr: RcExpr<String> = {
    EqExpr,
    <lo: @L> <lhs: EqExpr> "|" <rhs: PrimaryExpr> <hi: @R> => {
        Expr::binop(Span::new(lo, hi), Binop::Or, lhs, rhs).into()
    },
    <lo: @L> <lhs: EqExpr> "&" <rhs: PrimaryExpr> <hi: @R> => {
        Expr::binop(Span::new(lo, hi), Binop::And, lhs, rhs).into()
    },
};

EqExpr: RcExpr<String> = {
    CmpExpr,
    <lo: @L> <lhs: CmpExpr> "==" <rhs: EqExpr> <hi: @R> => {
        Expr::binop(Span::new(lo, hi), Binop::Eq, lhs, rhs).into()
    },
    <lo: @L> <lhs: CmpExpr> "!=" <rhs: EqExpr> <hi: @R> => {
        Expr::binop(Span::new(lo, hi), Binop::Ne, lhs, rhs).into()
    },
};

CmpExpr: RcExpr<String> = {
    AddExpr,
    <lo: @L> <lhs: AddExpr> "<=" <rhs: CmpExpr> <hi: @R> => {
        Expr::binop(Span::new(lo, hi), Binop::Le, lhs, rhs).into()
    },
    <lo: @L> <lhs: AddExpr> "<" <rhs: CmpExpr> <hi: @R> => {
        Expr::binop(Span::new(lo, hi), Binop::Lt, lhs, rhs).into()
    },
    <lo: @L> <lhs: AddExpr> ">" <rhs: CmpExpr> <hi: @R> => {
        Expr::binop(Span::new(lo, hi), Binop::Gt, lhs, rhs).into()
    },
    <lo: @L> <lhs: AddExpr> ">=" <rhs: CmpExpr> <hi: @R> => {
        Expr::binop(Span::new(lo, hi), Binop::Ge, lhs, rhs).into()
    },
};

AddExpr: RcExpr<String> = {
    MulExpr,
    <lo: @L> <lhs: MulExpr> "+" <rhs: AddExpr> <hi: @R> => {
        Expr::binop(Span::new(lo, hi), Binop::Add, lhs, rhs).into()
    },
    <lo: @L> <lhs: MulExpr> "-" <rhs: AddExpr> <hi: @R> => {
        Expr::binop(Span::new(lo, hi), Binop::Sub, lhs, rhs).into()
    },
};

MulExpr: RcExpr<String> = {
    PrefixExpr,
    <lo: @L> <lhs: PrefixExpr> "*" <rhs: MulExpr> <hi: @R> => {
        Expr::binop(Span::new(lo, hi), Binop::Mul, lhs, rhs).into()
    },
    <lo: @L> <lhs: PrefixExpr> "/" <rhs: MulExpr> <hi: @R> => {
        Expr::binop(Span::new(lo, hi), Binop::Div, lhs, rhs).into()
    },
};

PrefixExpr: RcExpr<String> = {
    AtomicExpr,
    <lo: @L> "-" <expr: AtomicExpr> <hi: @R> => {
        Expr::unop(Span::new(lo, hi), Unop::Neg, expr).into()
    },
    <lo: @L> "!" <value: AtomicExpr> <hi: @R> => {
        Expr::unop(Span::new(lo, hi), Unop::Not, value).into()
    },
};

AtomicExpr: RcExpr<String> = {
    "(" <expr: PrimaryExpr> ")" => expr,
    <lo: @L> <value: "BinLiteral"> <hi: @R> =>? {
        let suffix = value.1.parse().map_err(|e| UserError { error: GrammarError::from(e) })?;
        let const_int = Const::Int(value.0, suffix);

        Ok(Expr::Const(Span::new(lo, hi), const_int).into())
    },
    <lo: @L> <value: "HexLiteral"> <hi: @R> =>? {
        let suffix = value.1.parse().map_err(|e| UserError { error: GrammarError::from(e) })?;
        let const_int = Const::Int(value.0, suffix);

        Ok(Expr::Const(Span::new(lo, hi), const_int).into())
    },
    <lo: @L> <value: "DecLiteral"> <hi: @R> =>? {
        let suffix = value.1.parse().map_err(|e| UserError { error: GrammarError::from(e) })?;
        let const_int = Const::Int(value.0, suffix);

        Ok(Expr::Const(Span::new(lo, hi), const_int).into())
    },
    <lo: @L> <name: "Ident"> <hi: @R> => {
        Expr::fvar(Span::new(lo, hi), name).into()
    },
    <lo: @L> <struct_expr: AtomicExpr> "." <field_name: "Ident"> <hi: @R> => {
        Expr::proj(Span::new(lo, hi), struct_expr, field_name).into()
    },
    <lo: @L> <array_expr: AtomicExpr> "[" <index_expr: PrimaryExpr> "]" <hi: @R> => {
        Expr::subscript(Span::new(lo, hi), array_expr, index_expr).into()
    },
};
