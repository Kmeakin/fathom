use codespan::{ByteIndex, FileId, Span};
use codespan_reporting::Diagnostic;

use crate::concrete::{Module, Item, SpannedString};
use crate::parse::lexer::Token;

grammar(file_id: FileId, diagnostics: &mut Vec<Diagnostic>);

extern {
    type Location = ByteIndex;
    type Error = Diagnostic;

    enum Token {
        "identifier" => Token::Identifier(<String>),
        "doc comment" => Token::DocComment(<String>),
        "struct" => Token::Struct,
        "{" => Token::OpenBrace,
        "}" => Token::CloseBrace,
    }
}

pub Module: Module = {
    <items: Item*> => Module { file_id, items },
};

Item: Item = {
    <docs: "doc comment"*> <start: @L> "struct" <name: Identifier> "{" "}" <end: @R> => {
        let span = Span::from(start..end);
        let doc = super::concat_docs(docs);

        Item::Struct { span, doc, name }
    },
};

Identifier: SpannedString = {
    <start: @L> <name: "identifier"> => {
        SpannedString::new(start, name)
    },
};
