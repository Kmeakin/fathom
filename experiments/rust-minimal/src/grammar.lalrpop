use crate::{ByteRange, StringId, StringInterner};
use crate::surface::{Arena, Term};
use crate::surface::lexer::Token;

grammar<'arena, 'source>(interner: &mut StringInterner, arena: &'arena Arena<'arena>);

extern {
    type Location = usize;
    type Error = ();

    enum Token<'source> {
        "ident" => Token::Ident(<&'source str>),

        "fun" => Token::KeywordFun,
        "let" => Token::KeywordLet,
        "Type" => Token::KeywordType,

        "(" => Token::OpenParen,
        ")" => Token::CloseParen,

        ":" => Token::Colon,
        "=" => Token::Equals,
        "=>" => Token::EqualsGreater,
        "->" => Token::HyphenGreater,
        ";" => Token::Semicolon,
    }
}

pub Term: Term<'arena> = {
    FunTerm,
    // FIXME: LALRPOP does not accept raw identifiers (see: https://github.com/lalrpop/lalrpop/issues/613)
    <expr: FunTerm> ":" <type_: Term> => {
        Term::Ann(
            arena.alloc_term(expr),
            arena.alloc_term(type_),
        )
    },
    <start: @L> "let" <def_name: RangedName> <def_type: (":" < FunTerm>)?> "=" <def_expr: FunTerm> ";" <body_expr: Term> => {
        Term::Let(
            start,
            def_name,
            def_type.map(|def_type| arena.alloc_term(def_type) as &_),
            arena.alloc_term(def_expr),
            arena.alloc_term(body_expr),
        )
    },
};

FunTerm: Term<'arena> = {
    AppTerm,
    <start: @L> "fun" "("<input_name: RangedName> ":" <input_type: Term> ")" "->"  <output_type: FunTerm> => {
        Term::FunType(
            start,
            input_name,
            arena.alloc_term(input_type),
            arena.alloc_term(output_type),
        )
    },
    <start: @L> "fun" <input_name: RangedName> "=>" <output_type: FunTerm> => {
        Term::FunIntro(
            start,
            input_name,
            arena.alloc_term(output_type),
        )
    },
};

AppTerm: Term<'arena> = {
    AtomicTerm,
    <head_expr: AppTerm> <input_expr: AtomicTerm> => {
        Term::FunElim(
            arena.alloc_term(head_expr),
            arena.alloc_term(input_expr),
        )
    },
};

AtomicTerm: Term<'arena> = {
    <start: @L> <name: Name> <end: @R> => Term::Var(ByteRange::new(start, end), name),
    <start: @L> "Type" <end: @R> => Term::Universe(ByteRange::new(start, end)),
    "(" <term: Term> ")" => term,
};

#[inline]
Name: StringId = {
    <"ident"> => interner.get_or_intern(<>),
};

#[inline]
RangedName: (ByteRange, StringId) = {
    <start: @L> <name: Name> <end: @R> => (ByteRange::new(start, end), name),
};
