use scoped_arena::Scope;

use crate::{ByteRange, StringId, StringInterner};
use crate::surface::Term;
use crate::surface::lexer::Token;

grammar<'arena, 'source>(interner: &mut StringInterner, scope: &'arena Scope<'arena>);

extern {
    type Location = usize;
    type Error = ();

    enum Token<'source> {
        "ident" => Token::Ident(<&'source str>),

        "fun" => Token::KeywordFun,
        "let" => Token::KeywordLet,
        "Type" => Token::KeywordType,

        "U8" => Token::KeywordU8Type,
        "U16" => Token::KeywordU16Type,
        "U32" => Token::KeywordU32Type,
        "U64" => Token::KeywordU64Type,
        "S8" => Token::KeywordS8Type,
        "S16" => Token::KeywordS16Type,
        "S32" => Token::KeywordS32Type,
        "S64" => Token::KeywordS64Type,
        "F32" => Token::KeywordF32Type,
        "F64" => Token::KeywordF64Type,

        "Format" => Token::KeywordFormatType,
        "fail" => Token::KeywordFormatFail,
        "u8" => Token::KeywordFormatU8,
        "u16be" => Token::KeywordFormatU16Be,
        "u16le" => Token::KeywordFormatU16Le,
        "u32be" => Token::KeywordFormatU32Be,
        "u32le" => Token::KeywordFormatU32Le,
        "u64be" => Token::KeywordFormatU64Be,
        "u64le" => Token::KeywordFormatU64Le,
        "s8" => Token::KeywordFormatS8,
        "s16be" => Token::KeywordFormatS16Be,
        "s16le" => Token::KeywordFormatS16Le,
        "s32be" => Token::KeywordFormatS32Be,
        "s32le" => Token::KeywordFormatS32Le,
        "s64be" => Token::KeywordFormatS64Be,
        "s64le" => Token::KeywordFormatS64Le,
        "f32be" => Token::KeywordFormatF32Be,
        "f32le" => Token::KeywordFormatF32Le,
        "f64be" => Token::KeywordFormatF64Be,
        "f64le" => Token::KeywordFormatF64Le,

        ":" => Token::Colon,
        "," => Token::Comma,
        "=" => Token::Equals,
        "=>" => Token::EqualsGreater,
        "." => Token::FullStop,
        "->" => Token::HyphenGreater,
        "?" => Token::QuestionMark,
        ";" => Token::Semicolon,
        "_" => Token::Underscore,

        "{" => Token::OpenBrace,
        "}" => Token::CloseBrace,
        "(" => Token::OpenParen,
        ")" => Token::CloseParen,
    }
}

pub Term: Term<'arena> = {
    LetTerm,
    // FIXME: LALRPOP does not accept raw identifiers (see: https://github.com/lalrpop/lalrpop/issues/613)
    <expr: LetTerm> ":" <type_: Term> => {
        Term::Ann(
            scope.to_scope(expr),
            scope.to_scope(type_),
        )
    },
};

LetTerm: Term<'arena> = {
    FunTerm,
    <start: @L> "let" <def_name: RangedName> <def_type: (":" <FunTerm>)?> "=" <def_expr: LetTerm> ";" <body_expr: LetTerm> => {
        Term::Let(
            start,
            def_name,
            def_type.map(|def_type| scope.to_scope(def_type) as &_),
            scope.to_scope(def_expr),
            scope.to_scope(body_expr),
        )
    },
};

FunTerm: Term<'arena> = {
    AppTerm,
    <input_type: AppTerm> "->"  <output_type: FunTerm> => {
        Term::FunArrow(
            scope.to_scope(input_type),
            scope.to_scope(output_type),
        )
    },
    <start: @L> "fun" "(" <input_name: RangedName> ":" <input_type: Term> ")" "->"  <output_type: FunTerm> => {
        Term::FunType(
            start,
            input_name,
            scope.to_scope(input_type),
            scope.to_scope(output_type),
        )
    },
    <start: @L> "fun" <input_name: RangedName> "=>" <output_type: FunTerm> => {
        Term::FunIntro(
            start,
            input_name,
            scope.to_scope(output_type),
        )
    },
};

AppTerm: Term<'arena> = {
    AtomicTerm,
    <head_expr: AppTerm> <input_expr: AtomicTerm> => {
        Term::FunElim(
            scope.to_scope(head_expr),
            scope.to_scope(input_expr),
        )
    },
};

AtomicTerm: Term<'arena> = {
    <start: @L> <name: Name> <end: @R> => Term::Name(ByteRange::new(start, end), name),

    <start: @L> "Type" <end: @R> => Term::Universe(ByteRange::new(start, end)),

    <start: @L> "U8" <end: @R> => Term::U8Type(ByteRange::new(start, end)),
    <start: @L> "U16" <end: @R> => Term::U16Type(ByteRange::new(start, end)),
    <start: @L> "U32" <end: @R> => Term::U32Type(ByteRange::new(start, end)),
    <start: @L> "U64" <end: @R> => Term::U64Type(ByteRange::new(start, end)),
    <start: @L> "S8" <end: @R> => Term::S8Type(ByteRange::new(start, end)),
    <start: @L> "S16" <end: @R> => Term::S16Type(ByteRange::new(start, end)),
    <start: @L> "S32" <end: @R> => Term::S32Type(ByteRange::new(start, end)),
    <start: @L> "S64" <end: @R> => Term::S64Type(ByteRange::new(start, end)),
    <start: @L> "F32" <end: @R> => Term::F32Type(ByteRange::new(start, end)),
    <start: @L> "F64" <end: @R> => Term::F64Type(ByteRange::new(start, end)),

    <start: @L> "Format" <end: @R> => Term::FormatType(ByteRange::new(start, end)),
    <start: @L> "fail" <end: @R> => Term::FormatFail(ByteRange::new(start, end)),
    <start: @L> "u8" <end: @R> => Term::FormatU8(ByteRange::new(start, end)),
    <start: @L> "u16be" <end: @R> => Term::FormatU16Be(ByteRange::new(start, end)),
    <start: @L> "u16le" <end: @R> => Term::FormatU16Le(ByteRange::new(start, end)),
    <start: @L> "u32be" <end: @R> => Term::FormatU32Be(ByteRange::new(start, end)),
    <start: @L> "u32le" <end: @R> => Term::FormatU32Le(ByteRange::new(start, end)),
    <start: @L> "u64be" <end: @R> => Term::FormatU64Be(ByteRange::new(start, end)),
    <start: @L> "u64le" <end: @R> => Term::FormatU64Le(ByteRange::new(start, end)),
    <start: @L> "s8" <end: @R> => Term::FormatS8(ByteRange::new(start, end)),
    <start: @L> "s16be" <end: @R> => Term::FormatS16Be(ByteRange::new(start, end)),
    <start: @L> "s16le" <end: @R> => Term::FormatS16Le(ByteRange::new(start, end)),
    <start: @L> "s32be" <end: @R> => Term::FormatS32Be(ByteRange::new(start, end)),
    <start: @L> "s32le" <end: @R> => Term::FormatS32Le(ByteRange::new(start, end)),
    <start: @L> "s64be" <end: @R> => Term::FormatS64Be(ByteRange::new(start, end)),
    <start: @L> "s64le" <end: @R> => Term::FormatS64Le(ByteRange::new(start, end)),
    <start: @L> "f32be" <end: @R> => Term::FormatF32Be(ByteRange::new(start, end)),
    <start: @L> "f32le" <end: @R> => Term::FormatF32Le(ByteRange::new(start, end)),
    <start: @L> "f64be" <end: @R> => Term::FormatF64Be(ByteRange::new(start, end)),
    <start: @L> "f64le" <end: @R> => Term::FormatF64Le(ByteRange::new(start, end)),

    <start: @L> "?" <name: Name> <end: @R> => Term::Hole(ByteRange::new(start, end), Some(name)),
    <start: @L> "_" <end: @R> => Term::Hole(ByteRange::new(start, end), None),
    <start: @L> "{" "}" <end: @R> => Term::RecordEmpty(ByteRange::new(start, end)),
    <start: @L> "{" <first: (<RangedName> ":" <Term>)> <type_fields: ("," <RangedName> ":" <Term>)*> ","?  "}" <end: @R> => {
        let type_fields = std::iter::once(first).chain(type_fields).map(|(label, term)| (label, term));
        Term::RecordType(ByteRange::new(start, end), scope.to_scope_from_iter(type_fields))
    },
    <start: @L> "{" <first: (<RangedName> "=" <Term>)> <expr_fields: ("," <RangedName> "=" <Term>)*> ","?  "}" <end: @R> => {
        let type_fields = std::iter::once(first).chain(expr_fields).map(|(label, term)| (label, term));
        Term::RecordIntro(ByteRange::new(start, end), scope.to_scope_from_iter(type_fields))
    },
    <head_expr: AtomicTerm> "." <label: RangedName> => {
        Term::RecordElim(scope.to_scope(head_expr), label)
    },
    "(" <term: Term> ")" => term,
};

#[inline]
Name: StringId = {
    <"ident"> => interner.get_or_intern(<>),
};

#[inline]
RangedName: (ByteRange, StringId) = {
    <start: @L> <name: Name> <end: @R> => (ByteRange::new(start, end), name),
};
