// Combinators

let id : fun (A : ?) -> A -> A
  = fun A => fun a => a;

let always : fun (A : ?) -> fun (B : ?) -> A -> B -> A
  = fun A => fun B => fun a => fun B => a;


// Lists

let List : Type -> Type
  = fun Elem =>
      fun (List : ?) ->
      fun (cons : Elem -> List -> List) ->
      fun (nil : List) ->
        List;

let nil : fun (Elem : ?) -> List Elem
  = fun Elem => fun List => fun cons => fun nil => nil;

let cons : fun (Elem : ?) -> Elem -> List Elem -> List Elem
  = fun Elem => fun head => fun tail => fun List => fun cons => fun nil =>
      cons head (tail ? cons nil);


// Booleans

let Bool : Type
  = fun (Bool : ?) ->
      fun (true : Bool) ->
      fun (false : Bool) ->
        Bool;

let true : Bool
  = fun Bool => fun true => fun false => true;

let false : Bool
  = fun Bool => fun true => fun false => false;


let not : Bool -> Bool
  = fun bool => fun Bool => fun true => fun false =>
      bool Bool false true;


// Leibniz equality

let Eq : fun (A : ?) -> A -> A -> Type
  = fun A => fun a0 => fun a1 =>
      fun (P : fun (a : A) -> Type) -> fun (p : P a0) -> P a1;

let refl : fun (A : ?) -> fun (a : A) -> Eq A a a
  = fun A => fun a => fun P => fun pa => pa;


let sym : fun (A : ?) -> fun (a0 : A) -> fun (a1 : A) -> Eq ? a0 a1 -> Eq ? a1 a0
  = fun A => fun a0 => fun a1 => fun p =>
      p (fun a1 => Eq ? a1 a0) (refl ? ?);


// Natural numbers

let Nat : Type
  = fun (Nat : ?) ->
      fun (succ : Nat -> Nat) ->
      fun (zero : Nat) ->
        Nat;

let zero : Nat
    = fun Nat => fun succ => fun zero => zero;

let succ : Nat -> Nat
    = fun prev => fun Nat => fun succ => fun zero =>
        succ (prev ? succ zero);


let add : Nat -> Nat -> Nat
  = fun n0 => fun n1 => fun Nat => fun succ => fun zero =>
      n0 Nat succ (n1 Nat succ zero);

let mul : Nat -> Nat -> Nat
  = fun n0 => fun n1 => fun Nat => fun succ => fun zero =>
      n0 Nat (n1 Nat succ) zero;


// Examples

let id_elim_type = (fun a => a) Type;

let list1 : List Bool
  = cons ? (id ? true) (nil ?);

let five : Nat = succ (succ (succ (succ (succ zero))));
let ten : Nat = add five five;
let hundred : Nat = mul ten ten;
let thousand : Nat = mul ten hundred;

let eq_test : Eq ? hundred hundred = refl ? ?;

let eq_id_elim_type : Eq ? ((fun a => a) Type) Type = refl ? ?;
let eq_id_elim_true : Eq ? ((fun a => a) true) true = refl ? ?;
let eq_id_elim_false : Eq ? ((fun a => a) false) false = refl ? ?;


Type
