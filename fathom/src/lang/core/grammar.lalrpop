use std::sync::Arc;

use crate::lang::Ranged;
use crate::lang::core::{
    Constant, FieldDeclaration, ItemData, Module, Primitive, Sort, StructType, StructFormat, Term,
    TermData,
};
use crate::lang::core::lexer::Token;
use crate::literal;
use crate::reporting::{LexerMessage, Message};

grammar<'source>(file_id: usize, messages: &mut Vec<Message>);

extern {
    type Location = usize;
    type Error = LexerMessage;

    enum Token<'source> {
        "doc comment" => Token::DocComment(<String>),
        "inner doc comment" => Token::InnerDocComment(<String>),

        "name" => Token::Name(<&'source str>),
        "numeric literal" => Token::NumericLiteral(<&'source str>),
        "string literal" => Token::StringLiteral(<&'source str>),
        "character literal" => Token::CharLiteral(<&'source str>),

        "bool_elim" => Token::BoolElim,
        "const" => Token::Const,
        "f32" => Token::F32,
        "f64" => Token::F64,
        "Format" => Token::Format,
        "global" => Token::Global,
        "int" => Token::Int,
        "int_elim" => Token::IntElim,
        "item" => Token::Item,
        "Kind" => Token::Kind,
        "repr" => Token::Repr,
        "struct" => Token::Struct,
        "Type" => Token::Type,

        "{" => Token::OpenBrace,
        "}" => Token::CloseBrace,
        "(" => Token::OpenParen,
        ")" => Token::CloseParen,

        "!" => Token::Bang,
        ":" => Token::Colon,
        "," => Token::Comma,
        "=" => Token::Equals,
        "=>" => Token::EqualsGreater,
        "->" => Token::HyphenGreater,
        ";" => Token::Semi,
    }
}

pub Module: Module = {
    <doc: "inner doc comment"*> <items: Ranged<ItemData>*> => {
        Module {
            file_id,
            doc: Arc::from(doc),
            items,
        }
    },
};

ItemData: ItemData = {
    <doc: "doc comment"*> "const" <name: Name> "=" <term: Term> ";" => {
        ItemData::Constant(Constant {
            doc: Arc::from(doc),
            name,
            term: Arc::new(term),
        })
    },
    <docs: "doc comment"*>
    "struct" <name: Name> ":" "Type" "{"
        <mut fields: (<FieldDeclaration> ",")*>
        <last: FieldDeclaration?>
    "}" => {
        fields.extend(last);

        ItemData::StructType(StructType {
            doc: Arc::from(docs),
            name,
            fields
        })
    },
    <docs: "doc comment"*>
    "struct" <name: Name> ":" "Format" "{"
        <mut fields: (<FieldDeclaration> ",")*>
        <last: FieldDeclaration?>
    "}" => {
        fields.extend(last);

        ItemData::StructFormat(StructFormat {
            doc: Arc::from(docs),
            name,
            fields
        })
    },
};

#[inline]
FieldDeclaration: FieldDeclaration = {
    <doc: "doc comment"*> <label: Ranged<Name>> ":" <term: Term> => {
        FieldDeclaration {
            doc: Arc::from(doc),
            label,
            term: Arc::new(term),
        }
    },
};

#[inline] Term: Term = Ranged<TermData>;
#[inline] ArrowTerm: Term = Ranged<ArrowTermData>;
#[inline] AppTerm: Term = Ranged<AppTermData>;
#[inline] AtomicTerm: Term = Ranged<AtomicTermData>;

TermData: TermData = {
    ArrowTermData,
    <term: ArrowTerm> ":" <ty: Term> => TermData::Ann(Arc::new(term), Arc::new(ty)),
};

ArrowTermData: TermData = {
    AppTermData,
    <param_type: AppTerm> "->" <body_type: ArrowTerm> => {
        TermData::FunctionType(Arc::new(param_type), Arc::new(body_type))
    },
};

AppTermData: TermData = {
    AtomicTermData,
    <head: AtomicTerm> <argument: AtomicTerm> => {
        TermData::FunctionElim(Arc::new(head), Arc::new(argument))
    },
};

AtomicTermData: TermData = {
    "(" <term: TermData> ")" => term,
    "!" => TermData::Error,
    "global" <name: Name> => TermData::Global(name),
    "item" <name: Name> => TermData::Item(name),
    "Type" => TermData::Sort(Sort::Type),
    "Kind" => TermData::Sort(Sort::Kind),
    "repr" => TermData::Repr,
    "bool_elim" <head: Term> "{" <if_true: Term> "," <if_false: Term> "}" => {
        TermData::BoolElim(Arc::new(head), Arc::new(if_true), Arc::new(if_false))
    },
    "int_elim" <head: Term> "{"
        <branches: (<@L> <"numeric literal"> <@R> "=>" <Term> ",")*> <default: Term>
    "}" => {
        let branches = branches
            .into_iter()
            .filter_map(|(start, literal, end, term)| Some((
                literal::State::new(file_id, start..end, literal, messages).number_to_big_int()?,
                Arc::new(term),
            ))).collect();

        TermData::IntElim(Arc::new(head), branches, Arc::new(default))
    },
    "int" <start: @L> <literal: "numeric literal"> <end: @R> => {
        match literal::State::new(file_id, start..end, literal, messages).number_to_big_int() {
            Some(value) => TermData::Primitive(Primitive::Int(value)),
            None => TermData::Error,
        }
    },
    "f32" <start: @L> <literal: "numeric literal"> <end: @R> => {
        match literal::State::new(file_id, start..end, literal, messages).number_to_float() {
            Some(value) => TermData::Primitive(Primitive::F32(value)),
            None => TermData::Error,
        }
    },
    "f64" <start: @L> <literal: "numeric literal"> <end: @R> => {
        match literal::State::new(file_id, start..end, literal, messages).number_to_float() {
            Some(value) => TermData::Primitive(Primitive::F64(value)),
            None => TermData::Error,
        }
    },
    "Format" => TermData::FormatType,
};

#[inline]
FieldDefinition: (String, Arc<Term>) = {
    <label: Name> "=" <term: Term> => (label, Arc::new(term)),
};

#[inline]
Name: String = {
    <"name"> => (<>).to_owned(),
};

#[inline]
Ranged<T>: Ranged<T> = {
    <start: @L> <data: T> <end: @R> => Ranged::new(start..end, data),
};
