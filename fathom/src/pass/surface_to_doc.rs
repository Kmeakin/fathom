use std::borrow::Cow;
use std::collections::HashMap;
use std::io;
use std::io::prelude::*;

use crate::lang::surface;
use crate::pass::surface_to_pretty::Prec;

#[allow(clippy::write_literal)]
pub fn from_module(writer: &mut impl Write, module: &surface::Module) -> io::Result<()> {
    let mut context = Context {
        _file_id: module.file_id,
        items: HashMap::new(),
    };

    write!(
        writer,
        r##"<!--
  This file is automatically @generated by {pkg_name} {pkg_version}
  It is not intended for manual editing.
-->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>{module_name}</title>
    <style>
{minireset}

{style}
    </style>
  </head>
  <body>
    <section class="module">
"##,
        pkg_name = env!("CARGO_PKG_NAME"),
        pkg_version = env!("CARGO_PKG_VERSION"),
        module_name = "", // TODO: module name
        minireset = include_str!("./surface_to_doc/minireset.min.css").trim(),
        style = include_str!("./surface_to_doc/style.css").trim(),
    )?;

    if !module.doc.is_empty() {
        writeln!(writer, r##"      <section class="doc">"##)?;
        from_doc_lines(writer, "        ", &module.doc)?;
        writeln!(writer, r##"      </section>"##)?;
    }

    writeln!(writer, r##"      <dl class="items">"##)?;

    for item in &module.items {
        let (name, item) = match &item.data {
            surface::ItemData::Alias(alias) => context.from_alias(writer, alias)?,
            surface::ItemData::Struct(struct_type) => {
                context.from_struct_type(writer, struct_type)?
            }
        };

        context.items.insert(name, item);
    }

    write!(
        writer,
        r##"      </dl>
    </section>
  </body>
</html>
"##
    )?;

    Ok(())
}

struct Context {
    _file_id: usize,
    items: HashMap<String, Item>,
}

struct Item {
    id: String,
}

impl Context {
    fn from_alias(
        &self,
        writer: &mut impl Write,
        alias: &surface::Alias,
    ) -> io::Result<(String, Item)> {
        let id = format!("items[{}]", alias.name.data);

        writeln!(
            writer,
            r##"        <dt id="{id}" class="item alias">"##,
            id = id,
        )?;
        match &alias.type_ {
            None => writeln!(
                writer,
                r##"          <a href="#{id}">{name}</a>"##,
                id = id,
                name = alias.name.data,
            )?,
            Some(r#type) => writeln!(
                writer,
                r##"          <a href="#{id}">{name}</a> : {type}"##,
                id = id,
                name = alias.name.data,
                type = self.from_term_prec(r#type, Prec::Term),
            )?,
        }
        write!(
            writer,
            r##"        </dt>
        <dd class="item alias">
"##
        )?;

        if !alias.doc.is_empty() {
            writeln!(writer, r##"          <section class="doc">"##)?;
            from_doc_lines(writer, "            ", &alias.doc)?;
            writeln!(writer, r##"          </section>"##)?;
        }

        let term = self.from_term_prec(&alias.term, Prec::Term);

        write!(
            writer,
            r##"          <section class="term">
            {}
          </section>
        </dd>
"##,
            term
        )?;

        Ok((alias.name.data.clone(), Item { id }))
    }

    fn from_struct_type(
        &self,
        writer: &mut impl Write,
        struct_type: &surface::StructType,
    ) -> io::Result<(String, Item)> {
        let id = format!("items[{}]", struct_type.name.data);

        write!(
            writer,
            r##"        <dt id="{id}" class="item struct">
          struct <a href="#{id}">{name}</a>
        </dt>
        <dd class="item struct">
"##,
            id = id,
            name = struct_type.name.data,
        )?;

        if !struct_type.doc.is_empty() {
            writeln!(writer, r##"          <section class="doc">"##)?;
            from_doc_lines(writer, "            ", &struct_type.doc)?;
            writeln!(writer, r##"          </section>"##)?;
        }

        if !struct_type.fields.is_empty() {
            writeln!(writer, r##"          <dl class="fields">"##)?;
            for field in &struct_type.fields {
                let field_id = format!("{}.fields[{}]", id, field.name.data);
                let r#type = self.from_term_prec(&field.term, Prec::Term);

                write!(
                    writer,
                    r##"            <dt id="{id}" class="field">
              <a href="#{id}">{name}</a> : {type}
            </dt>
            <dd class="field">
              <section class="doc">
"##,
                    id = field_id,
                    name = field.name.data,
                    type = r#type,
                )?;
                from_doc_lines(writer, "                ", &field.doc)?;
                write!(
                    writer,
                    r##"              </section>
            </dd>
"##
                )?;
            }
            writeln!(writer, r##"          </dl>"##)?;
        }

        writeln!(writer, r##"        </dd>"##)?;

        Ok((struct_type.name.data.clone(), Item { id }))
    }

    fn from_term_prec<'term>(&self, term: &'term surface::Term, prec: Prec) -> Cow<'term, str> {
        use itertools::Itertools;

        match &term.data {
            surface::TermData::Name(name) => {
                let id = match self.items.get(name) {
                    Some(item) => item.id.as_str(),
                    None => "",
                };

                format!(r##"<var><a href="#{}">{}</a></var>"##, id, name).into()
            }
            surface::TermData::TypeType => "Type".into(),
            surface::TermData::Ann(term, r#type) => format!(
                "{lparen}{term} : {type}{rparen}",
                lparen = if prec > Prec::Term { "(" } else { "" },
                rparen = if prec > Prec::Term { ")" } else { "" },
                term = self.from_term_prec(term, Prec::Arrow),
                type = self.from_term_prec(r#type, Prec::Term),
            )
            .into(),
            surface::TermData::FunctionType(param_type, body_type) => format!(
                "{lparen}{param_type} &rarr; {body_type}{rparen}",
                lparen = if prec > Prec::Arrow { "(" } else { "" },
                rparen = if prec > Prec::Arrow { ")" } else { "" },
                param_type = self.from_term_prec(param_type, Prec::App),
                body_type = self.from_term_prec(body_type, Prec::Arrow),
            )
            .into(),
            surface::TermData::FunctionElim(head, arguments) => format!(
                // TODO: multiline formatting!
                "{lparen}{head} {arguments}{rparen}",
                lparen = if prec > Prec::App { "(" } else { "" },
                rparen = if prec > Prec::App { ")" } else { "" },
                head = self.from_term_prec(head, Prec::Atomic),
                arguments = arguments
                    .iter()
                    .map(|argument| self.from_term_prec(argument, Prec::Atomic))
                    .format(" "),
            )
            .into(),
            surface::TermData::NumberLiteral(literal) => format!("{}", literal).into(),
            surface::TermData::If(head, if_true, if_false) => format!(
                // TODO: multiline formatting!
                "if {head} {{ {if_true} }} else {{ {if_false} }}",
                head = self.from_term_prec(head, Prec::Term),
                if_true = self.from_term_prec(if_true, Prec::Term),
                if_false = self.from_term_prec(if_false, Prec::Term),
            )
            .into(),
            surface::TermData::Match(head, branches) => format!(
                // TODO: multiline formatting!
                "match {head} {{ {branches} }}",
                head = self.from_term_prec(head, Prec::Term),
                branches = branches
                    .iter()
                    .map(|(pattern, term)| format!(
                        "{pattern} &rArr; {term}",
                        pattern = self.from_pattern(pattern),
                        term = self.from_term_prec(term, Prec::Term),
                    ))
                    .format(", "),
            )
            .into(),
            surface::TermData::FormatType => "Format".into(),
            surface::TermData::Error => r##"<strong>(invalid data description)</strong>"##.into(),
        }
    }

    fn from_pattern<'term>(&self, pattern: &'term surface::Pattern) -> Cow<'term, str> {
        match &pattern.data {
            surface::PatternData::Name(name) => format!(r##"<a href="#">{}</a>"##, name).into(), // TODO: add local binding
            surface::PatternData::NumberLiteral(literal) => format!("{}", literal).into(),
        }
    }
}

fn from_doc_lines(writer: &mut impl Write, prefix: &str, doc_lines: &[String]) -> io::Result<()> {
    // TODO: parse markdown

    for doc_line in doc_lines.iter() {
        let doc_line = match doc_line {
            line if line.starts_with(' ') => &line[" ".len()..],
            line => &line[..],
        };
        writeln!(writer, "{}{}", prefix, doc_line)?;
    }

    Ok(())
}
